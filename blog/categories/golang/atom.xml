<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | sgykfjsm.github.com]]></title>
  <link href="http://sgykfjsm.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://sgykfjsm.github.io/"/>
  <updated>2017-09-11T22:47:56+09:00</updated>
  <id>http://sgykfjsm.github.io/</id>
  <author>
    <name><![CDATA[sgykfjsm]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GolangのSignalハンドリングを同時に複数実行したらどうなるか]]></title>
    <link href="http://sgykfjsm.github.io/blog/2017/09/05/golangfalsesignalhandoringuwotong-shi-nifu-shu-shi-xing-sitaradounaruka/"/>
    <updated>2017-09-05T22:03:39+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2017/09/05/golangfalsesignalhandoringuwotong-shi-nifu-shu-shi-xing-sitaradounaruka</id>
    <content type="html"><![CDATA[<p>めっちゃ久しぶりにブログを書く。標題の件が気になったので実際にやってみた。</p>

<!-- more -->


<p>シンプルなSignalハンドラはこんな感じになる。ほぼ<a href="https://gobyexample.com/signals">Go By Example</a>と同じ。何度も写経しているうちに暗記した。</p>

<pre><code class="go">package main

import (
    "fmt"
    "os"
    "os/signal"
    "syscall"
)

func main() {
    sig := make(chan os.Signal, 1)
    done := make(chan bool, 1)

    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        s := &lt;-sig
        fmt.Printf("\nCatch the signal at main: %v\n", s)
        done &lt;- true
    }()

    fmt.Println("Waiting for signal at main ...")
    &lt;-done
    fmt.Println("Exit from main")
}
</code></pre>

<p>次にほぼこれをコピペしてライブラリとしてインポートする。そうすると、以下のようになる。</p>

<p>main.go</p>

<pre><code class="go">package main

import (
    "fmt"
    "os"
    "os/signal"
    "syscall"

    "github.com/sgykfjsm/sample-program-by-go/signal-handler/sub1"
    "github.com/sgykfjsm/sample-program-by-go/signal-handler/sub2"
    "sync"
)

func main() {
    sig := make(chan os.Signal, 1)
    done := make(chan bool, 1)

    var wg sync.WaitGroup

    go sub1.Sub1(&amp;wg)
    go sub2.Sub2(&amp;wg)

    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    wg.Add(1)
    go func() {
        defer wg.Done()
        s := &lt;-sig
        fmt.Printf("\nCatch the signal at main: %v\n", s)
        done &lt;- true
    }()

    fmt.Println("Waiting for signal at main ...")
    wg.Wait()
    &lt;-done
    fmt.Println("Exit from main")
}
</code></pre>

<p>sub1/sub.go</p>

<pre><code class="go">package sub1

import (
    "fmt"
    "os"
    "os/signal"
    "sync"
    "syscall"
)

func Sub1(wg *sync.WaitGroup) {
    // Don't put wg.Wait(). This should be done at caller function.
    wg.Add(1)
    sig := make(chan os.Signal, 1)
    done := make(chan bool, 1)

    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        defer wg.Done()
        s := &lt;-sig
        fmt.Printf("\nCatch the signal at Sub1: %v\n", s)
        done &lt;- true
    }()

    fmt.Println("Waiting for signal at Sub1 ...")
    &lt;-done
    fmt.Println("Exit from Sub1")
}
</code></pre>

<p>sub2/sub.goも作っているけど、sub1/sub.goとほぼ同じなので省略。先にmain.goがexitしないように<code>sync.Waitgroup</code>を使って待ち合わせをする。実行結果は以下の通り。</p>

<pre><code class="console">$ go run ./main.go
Waiting for signal at main ...
Waiting for signal at Sub2 ...
Waiting for signal at Sub1 ...
^C
Catch the signal at Sub1: interrupt
Exit from Sub1

Catch the signal at main: interrupt

Catch the signal at Sub2: interrupt
Exit from main

$ go run ./main.go
Waiting for signal at main ...
Waiting for signal at Sub1 ...
Waiting for signal at Sub2 ...
^C
Catch the signal at main: interrupt

Catch the signal at Sub1: interrupt
Exit from Sub1

Catch the signal at Sub2: interrupt
Exit from main

$ go run ./main.go
Waiting for signal at main ...
Waiting for signal at Sub2 ...
Waiting for signal at Sub1 ...
^C
Catch the signal at main: interrupt

Catch the signal at Sub2: interrupt
Exit from Sub2

Catch the signal at Sub1: interrupt
Exit from main
</code></pre>

<p>見ての通り、各ハンドラは同一のシグナルを同様に受け取っていることがわかる。まぁそりゃそうだという感じ。実際にコード（というかgodoc）にも以下の様に<a href="https://github.com/golang/go/blob/master/src/os/signal/signal.go#L102-L104">記述されている</a>。</p>

<blockquote><p>It is allowed to call Notify multiple times with different channels
and the same signals: each channel receives copies of incoming
signals independently.</p></blockquote>

<p>ただし、上記出力からもう１つわかることとして、ライブラリ側の<code>wg.Done()</code>以降の処理は必ずしも全うするとは限らないということだ。そのため、例えば、シグナルを受け取ったらメモリに溜まっているデータをFlushして何らかの処理などを行う必要がある場合、呼び出し側の処理を止めてライブラリ側の処理を終了させてから次に呼び出し側の処理を再開するような実装をしなければならない。</p>

<p>今回のサンプルの場合であれば、<code>wg.Done</code>を処理の一番最後に持っていけば良い。例えば、以下の様にする。</p>

<pre><code class="go">func Sub2(wg *sync.WaitGroup) {
    defer wg.Done() // &lt;-- 処理の最初にdeferでwg.Doneを登録する。
    // Don't put wg.Wait(). This should be done at caller function.
    wg.Add(1)
    sig := make(chan os.Signal, 1)
    done := make(chan bool, 1)

    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        s := &lt;-sig
        fmt.Printf("\nCatch the signal at Sub2: %v\n", s)
        done &lt;- true
    }()

    fmt.Println("Waiting for signal at Sub2 ...")
    &lt;-done
    fmt.Println("Exit from Sub2")
}
</code></pre>

<p>しかし、現実として呼び出し側から<code>wg *sync.WaitGroup</code>を渡してもらうということは実装として通常はありえない。ではどうするか？</p>

<p>１つの方法としては<a href="https://golang.org/pkg/runtime/#SetFinalizer">runtime.SetFinalizer</a>を使う方法がある。これはGCが発動する際にGC処理のfinalizerとして処理を登録する方法だ。参考の実装は <a href="https://gist.github.com/deltamobile/6511901">https://gist.github.com/deltamobile/6511901</a> がある。<a href="https://play.golang.org/p/jWhRSPNvxJ">https://play.golang.org/p/jWhRSPNvxJ</a> で動作を確認することができる。一見、これは有用に見えるが、GC処理のfinalizerとするのはあまり実用的ではない。</p>

<p>自分がおもいつく限りだと<code>sync.Mutex</code>を使った排他制御かなーと思ったけど、どういう風に実装にすれば良いか思いつかない。やっぱりシンプルにチャンネルを渡して、呼び出し側が渡したチャンネルから終了の合図を受け取る方法かなぁ？</p>

<p>main.go</p>

<pre><code class="go">package main

import (
    "fmt"
    "os"
    "os/signal"
    "syscall"

    "github.com/sgykfjsm/sample-program-by-go/signal-handler/sub1"
    "github.com/sgykfjsm/sample-program-by-go/signal-handler/sub2"
)

func main() {
    sig := make(chan os.Signal, 1)
    done := make(chan bool, 1)
    sub1Done := make(chan bool, 1)
    sub2Done := make(chan bool, 1)

    go sub1.Sub1(sub1Done)
    go sub2.Sub2(sub2Done)

    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        s := &lt;-sig
        fmt.Printf("\nCatch the signal at main: %v\n", s)
        done &lt;- true
    }()

    fmt.Println("Waiting for signal at main ...")
    &lt;-done
    fmt.Println("Exit from main")

    &lt;-sub1Done
    &lt;-sub2Done
}
</code></pre>

<p>sub1/sub.go</p>

<pre><code class="go">package sub1

import (
    "fmt"
    "os"
    "os/signal"
    "syscall"
)

func Sub1(done chan&lt;- bool) {
    sig := make(chan os.Signal, 1)
    subDone := make(chan bool, 1)

    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        s := &lt;-sig
        fmt.Printf("\nCatch the signal at Sub1: %v\n", s)
        subDone &lt;- true
    }()

    fmt.Println("Waiting for signal at Sub1 ...")
    &lt;-subDone
    fmt.Println("Exit from Sub1")

    done &lt;- true
}
</code></pre>

<p>結果は以下の通り。</p>

<pre><code class="console">$ go run ./main.go
Waiting for signal at main ...
Waiting for signal at Sub2 ...
Waiting for signal at Sub1 ...
^C
Catch the signal at main: interrupt
Exit from main

Catch the signal at Sub2: interrupt
Exit from Sub2

Catch the signal at Sub1: interrupt
Exit from Sub1

$ go run ./main.go
Waiting for signal at main ...
Waiting for signal at Sub2 ...
Waiting for signal at Sub1 ...
^C
Catch the signal at Sub2: interrupt
Exit from Sub2

Catch the signal at main: interrupt
Exit from main

Catch the signal at Sub1: interrupt
Exit from Sub1

$ go run ./main.go
Waiting for signal at main ...
Waiting for signal at Sub1 ...
Waiting for signal at Sub2 ...
^C
Catch the signal at Sub2: interrupt
Exit from Sub2

Catch the signal at main: interrupt
Exit from main

Catch the signal at Sub1: interrupt
Exit from Sub1
</code></pre>

<p>一応は期待通りに、ライブラリ側の処理を全うして呼び出し側が終了させることが出来た。最初の例と何が違うのかって言われるとちょっと困るけど、チャンネルを通じたコミュニケーションということで、こっちのほうがGoっぽいかな？という程度…どこかに最適解がありそうな気がするけど、まぁ今日はこのへんで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GoでJSON APIを書く Part2]]></title>
    <link href="http://sgykfjsm.github.io/blog/2016/03/13/golang-json-api-tutorial-pt2/"/>
    <updated>2016-03-13T23:27:51+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2016/03/13/golang-json-api-tutorial-pt2</id>
    <content type="html"><![CDATA[<p><a href="/blog/2016/03/13/golang-json-api-tutorial/">前回</a>の続き。全体的にちょっとアレなところが多いので、もう少しリファクタリングを行なう。今回のリファクタリングの元ネタは以下。元ネタのほうが説明が簡潔だしコードが綺麗なので、元ネタを読めばコレを読む必要は無い。</p>

<ul>
<li><a href="http://openmymind.net/Go-action-responses/">Go actions responses</a></li>
</ul>


<!-- more -->


<a name="L.........................................."></a>
<h2>主処理の結果を受け取りたい。</h2>

<p>見出しの通りなんだけど、例えば現在のロギング内容にステータスコードを出力したいと思ったら、主処理から処理結果を受け取り、HTTPステータスコードを取り出す必要がある。また、事後処理にHTTPステータスコードを設定させるようにするのも同様だ。しかし、現在のハンドラからは処理結果を受け取ることができない。なぜならば、各Middlewareは<code>httprouter.Handle</code>をハンドラとして定義しており、<code>httprouter.Handle</code>は以下のように定義されているからだ。</p>

<pre><code class="go">// Handle is a function that can be registered to a route to handle HTTP
// requests. Like http.HandlerFunc, but has a third parameter for the values of
// wildcards (variables).
type Handle func(http.ResponseWriter, *http.Request, Params)
</code></pre>

<p>つまりハンドラには返り値が無い。というわけで、今回の目的を実現するには、まずハンドラの定義を自分で変えなければならない。また、ハンドラを自分で定義するとhttprouterを使い続けるのが難しくなるため、別の方法でroutingを実装する必要がある。これについては後述する。</p>

<a name="L.............................."></a>
<h3>アプローチを考える。</h3>

<p>考えを整理しよう。大雑把に考えると、主処理はリクエストを受け取って処理結果を返却してくれればよい。例えば以下の様な感じだ。</p>

<pre><code class="go">func DoSomething(r *http.Request) Result {

    // Do something

    return Result
}
</code></pre>

<p>実際のところ、レスポンスを生成する処理は主処理の役割ではないため引数から<code>w http.ResponseWriter</code>を削除した。また、httprouterが使えなくなるため、<code>ps httprouter.Params</code>も削除した。</p>

<p><code>Result</code>の部分は事後処理のことを考えると、HTTP Responseと対応してるっぽく定義したほうが良さそうだ。また、現在の事後処理はレスポンスヘッダーの設定を担当しているが、いっそレスポンスに関することを全て対応して欲しい。この考えを元に<code>Result</code>を<code>Response</code>に変更し、<code>Response</code>をstructとして以下のように定義する。</p>

<pre><code class="go">type Response struct {
    status int          // HTTPステータスコードに対応する
    body   []byte       // レスポンスボディに対応する
    header http.Header  // HTTPレスポンスヘッダーに対応する
}
</code></pre>

<p><code>Response</code>をもう少し考える。今回の主処理のレスポンスは以下のように分類できる。</p>

<ul>
<li>GETメソッドの結果を<code>200 OK</code>でJSONレスポンスを返す</li>
<li>POSTメソッドの結果は<code>204 Created</code>でをJSONレスポンスを返す</li>
<li>DELETEメソッドの場合は何も返却しない</li>
<li>エラーが発生した場合はJSONでエラーメッセージを返す</li>
<li>上記に挙げた処理はそれぞれ基本的なレスポンス生成処理に基づく</li>
</ul>


<p>また、<code>Response</code>でやりたいことはレスポンス生成とロギングのためにHTTPステータスコードを取り出せるようにすることだ。この時点では具体的な実装は未定なので、やりたいことを<code>interface</code>として記述する。</p>

<pre><code class="go">type Response interface {
    Write(w http.ResponseWriter) // レスポンスを生成
    Status() int                 // ステータスコードを取り出す
}
</code></pre>

<p>ここでinterfaceの名前が先ほど定義したstructと被ってしまった。レスポンスを定義するstructはinterfaceを実装するようにしていたほうが何かと便利なので、interfaceのほうを尊重してstructの名前を<code>NormalResponse</code>とする。主処理はこの<code>Response</code> interfaceだけを意識するようにしておけば、レスポンス側の実装に影響を受けにくくなる。</p>

<a name="response.go"></a>
<h3>response.go</h3>

<p>以上を踏まえて、<code>Response</code>を作る処理は以下のようになる。</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "log"
    "net/http"
)

type Response interface {
    Write(w http.ResponseWriter)
    Status() int
}

type NormalResponse struct {
    status int         // HTTPステータスコードに対応する
    body   []byte      // レスポンスボディに対応する
    header http.Header // HTTPレスポンスヘッダーに対応する
}

func (r *NormalResponse) Write(w http.ResponseWriter) {
    header := w.Header()
    for k, v := range r.header {
        header[k] = v
    }
    w.WriteHeader(r.status)
    w.Write(r.body)
}

func (r *NormalResponse) Status() int {
    return r.status
}

func (r *NormalResponse) Header(key, value string) *NormalResponse {
    r.header.Set(key, value)
    return r
}

func Empty(status int) *NormalResponse {
    return Respond(status, nil)
}

func Json(status int, body interface{}) *NormalResponse {
    return Respond(status, body).Header("Content-Type", "application/json")
}

func Created(status int, body interface{}, location string) *NormalResponse {
    return Json(status, body).Header("Location", location)
}

func Error(status int, message string, err error) *NormalResponse {
    log.Printf("%s, %s", message, err)
    return Respond(status, message).Header("Content-Type", "application/json")
}

func Respond(status int, body interface{}) *NormalResponse {
    var b []byte
    var err error
    switch t := body.(type) {
    case string:
        b = []byte(t)
    default:
        if b, err = json.Marshal(body); err != nil {
            return Error(http.StatusInternalServerError, "failed marshalling json", err)
        }
    }

    return &amp;NormalResponse{
        status: status,
        body:   b,
        header: make(http.Header),
    }
}
</code></pre>

<p>この処理で注目すべき点は各処理の<code>body</code>の型が<code>interface</code>となっていることだ。引数を<code>interface</code>で抽象化することで多くのデータ型に対応することが可能となる。</p>

<p><code>Respond</code>は各処理からレスポンスを生成するための材料を受け取る。<code>switch</code>の文を見てわかるように、<code>body.(type)</code>でデータ型を取り出し、それぞれのデータ型に合わせて処理を分岐させている。</p>

<p>また、<code>Respond</code>は<code>NormalResponse</code>を返却する際に、<code>make(http.Header)</code>を<code>NormalResponse.header</code>に割り当てている。これにより、<code>Respond</code>を利用する各処理の内部でレスポンスヘッダーを設定することが可能となっている。</p>

<a name="Middleware..............."></a>
<h2>Middlewareを修正する</h2>

<p>上記のように事後処理を実装したが、これにより、<code>decorator.go</code>に定義した<code>CommonHeaders</code>が不要となる。また、忘れてしまいそうになるが、今回の修正では独自のハンドラを定義しなければならない。先述したように主処理に必要なのは<code>r *http.Request</code>だけで<code>Response</code> interfaceを返却するだけなので、以下のように定義できる。</p>

<pre><code class="go">type MyHandle func(*http.Request) Response
</code></pre>

<p>これに基づき、<code>decorator.go</code>と<code>logger.go</code>を以下のように修正する。</p>

<a name="decorator.go"></a>
<h3>decorator.go</h3>

<pre><code class="go">package main

import (
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
)

type MyHandle func(*http.Request) Response

func IDShouldBeInt(h func(r *http.Request) Response, name string) MyHandle {
    return Logging(func(r *http.Request) Response {
        _, err := strconv.Atoi(mux.Vars(r)["todoId"])
        if err != nil {
            return Error(422, "todoId should be number", err)
        }

        return h(r)
    }, name)
}
</code></pre>

<p>上記を見てわかると思うけど、<code>github.com/gorilla/mux</code>を使っている。これはhttprouterの代わりとしているため。実際には、この時点では<code>r.URL.Query().Get("todoId")</code>でパラメータを取り出していた。</p>

<p>さて、ここでの修正は以下のとおりだ。</p>

<ul>
<li><code>CommonHeaders</code>の削除</li>
<li><code>IDShouldBeInt</code>は削除された<code>CommonHeaders</code>の代わりに<code>Logging</code>を設定</li>
<li>レスポンス生成処理を削除</li>
</ul>


<p>これだけを書いてもちょっとわかりにくいので参考までに修正前のコードを抜粋する。比較するとかなりシンプルになったことがわかる。</p>

<pre><code class="go">// これは修正前のコード
func IDShouldBeInt(h httprouter.Handle, name string) httprouter.Handle {
    return CommonHeaders(func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
        idParam := ps.ByName("todoId")
        _, err := strconv.Atoi(idParam)
        if err != nil {
            w.Header().Set("Content-Type", "application/json; charset=UTF-8")
            w.WriteHeader(500)
            if err := json.NewEncoder(w).Encode(err); err != nil {
                return
            }
            return
        }

        h(w, r, ps)
    }, name)
}
</code></pre>

<a name="logger.go"></a>
<h3>logger.go</h3>

<pre><code class="go">package main

import (
    "log"
    "net/http"
    "time"
)

var logger = func(method, uri, name string, status int, start time.Time) {
    log.Printf("\"method\":%q   \"uri\":%q  \"name\":%q \"status\":%d   \"time\":%q", method, uri, name, status, time.Since(start))
}

func Logging(h func(r *http.Request) Response, name string) MyHandle {
    return func(r *http.Request) Response {
        start := time.Now()
        result := h(r)
        logger(r.Method, r.URL.Path, name, result.Status(), start)
        return result
    }
}
</code></pre>

<p>ここでようやく主処理から結果を受け取れるようになったことが確認できると思う。</p>

<a name="L........................"></a>
<h2>主処理を修正する</h2>

<p>ここまでくればやることは自ずと決まる。つまり、以下のことをやれば良い。</p>

<ul>
<li>httprouterに関する部分を削除する。</li>
<li>各処理の返却時には<code>Response</code> interfaceのデータを返却する。</li>
</ul>


<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
    "io"
    "io/ioutil"
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
)

func Index(r *http.Request) Response {
    return Respond(http.StatusOK, "Welcmoe")
}

func TodoIndex(r *http.Request) Response {
    return Json(http.StatusOK, todos)
}

func TodoShow(r *http.Request) Response {
    id, _ := strconv.Atoi(mux.Vars(r)["todoId"])
    t := RepoFindTodo(id)
    if t.ID == 0 &amp;&amp; t.Name == "" {
        return Empty(http.StatusNotFound)
    }

    return Json(http.StatusOK, t)
}

func TodoCreate(r *http.Request) Response {
    var todo Todo

    body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576)) // 1MiB
    if err != nil {
        return Error(http.StatusInternalServerError, "request body is too large", err)
    }
    defer r.Body.Close()

    if err := json.Unmarshal(body, &amp;todo); err != nil {
        return Error(http.StatusInternalServerError, "failed marshalling json", err)
    }

    t := RepoCreateTodo(todo)
    location := fmt.Sprintf("http://%s/%s/%d", r.Host, r.URL.Path, t.ID)

    return Created(http.StatusCreated, t, location)
}

func TodoDelete(r *http.Request) Response {
    id, _ := strconv.Atoi(mux.Vars(r)["todoId"])
    if err := RepoDestroyTodo(id); err != nil {
        return Empty(http.StatusNotFound)
    }

    return Empty(204) // 204 No Content
}
</code></pre>

<a name="main.go..............."></a>
<h2>main.goを修正する</h2>

<p>何度も繰り返しているようにhttprouterはもう使えない。標準の<code>mux</code>を使ってもいいけどMethodによるルーティングなどを自分で実装するのはいかにも面倒くさい。すでにネタバレしているけど、今回のような状況では<code>github.com/gorilla/mux</code>が使いやすい。</p>

<ul>
<li><a href="https://github.com/gorilla/mux">github.com/gorilla/mux</a></li>
</ul>


<p>また、今回は独自のハンドラを定義したことを思い出して欲しい。このままでは支障があるため、<code>func(http.ResponseWriter, *http.Request)</code>を返却するラッパーを用意しなければならない。実は<code>Response</code>をHTTPレスポンスとして出力する処理が記述されていないが、このラッパーに記述することで最後にHTTPレスポンスを生成することができるようになる。つまり、今後、新たなMiddlewareを実装するとしてもそれらはHTTPレスポンスへの書き出しを意識しなくて良くなるということだ。</p>

<a name="main.go"></a>
<h3>main.go</h3>

<p>以上を踏まえると、<code>main.go</code>は以下のようになる。</p>

<pre><code class="go">package main

import (
    "log"
    "net/http"

    "github.com/gorilla/mux"
)

func decorator(h func(r *http.Request) Response) func(http.ResponseWriter, *http.Request) {
    return func(w http.ResponseWriter, r *http.Request) {
        result := h(r)
        result.Write(w)
    }
}

func main() {
    r := mux.NewRouter()
    r.HandleFunc("/", decorator(Logging(Index, "index"))).Methods("GET")
    r.HandleFunc("/todos", decorator(Logging(TodoIndex, "todo-index"))).Methods("GET")
    r.HandleFunc("/todos/{todoId}", decorator(IDShouldBeInt(TodoShow, "todo-show"))).Methods("GET")
    r.HandleFunc("/todos", decorator(Logging(TodoCreate, "todo-create"))).Methods("POST")
    r.HandleFunc("/todos/{todoId}", decorator(IDShouldBeInt(TodoDelete, "todo-delete"))).Methods("DELETE")

    http.Handle("/", r)

    log.Println("start")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
</code></pre>

<p><code>main.go</code>に関しては以前よりもごちゃごちゃしてしまった…。ちょっと丸括弧の数が多すぎるか。このあたりは今後の課題だなぁ。</p>

<a name="L............"></a>
<h2>おさらい</h2>

<p>以上、GoでJSON APIを作る方法を見てきた。まぁまぁ良い感じのコードになったんじゃないかなーとは思うけど、最後の<code>main.go</code>はかなりいただけない感じになってしまった。まぁこの辺は自力でちゃんとやろうとするよりも素直にWeb Frameworkを使ったほうが良いと思う。ここまでやっといてなんだけど。しかし、Goの世界ではまだデファクトスタンダードとなるような安定したWeb Frameworkが無いのもまた事実で、シンプルなAPI程度ならばまだスクラッチで実装するほうが良いと個人的には思う。その場合、パッケージの選定には注意したい。httprouterのように優れた性能であっても利用者に一定の制約（多くの場合は問題にならないし、むしろメリットのほうが大きいが）を課すことがある。そういった制約の中でどこまで何ができるのかを早々に見極めないとハマることになるし、Goは続々と色々なパッケージが作られているのでさっさと見切りをつけてパッケージを乗り換えたほうが良い。</p>

<p>今回のコードは <a href="https://gist.github.com/sgykfjsm/1dd9a8eee1f70a7068c9">https://gist.github.com/sgykfjsm/1dd9a8eee1f70a7068c9</a> にアップした。興味があれば見てみると良い。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GoでJSON APIを書く]]></title>
    <link href="http://sgykfjsm.github.io/blog/2016/03/13/golang-json-api-tutorial/"/>
    <updated>2016-03-13T23:21:43+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2016/03/13/golang-json-api-tutorial</id>
    <content type="html"><![CDATA[<p>JSONを返すRESTful APIを作ることになったので諸々の復習を兼ねて<a href="http://thenewstack.io/make-a-restful-json-api-go/">Making a RESTful JSON API in Go</a>を読む。そのままだとつまらないのでところどころ微妙にアレンジしながらやってみる。</p>

<!-- more -->


<a name="A.Basic.Web.Server"></a>
<h2>A Basic Web Server</h2>

<p>RESTfulなAPI Serverを作る場合、当然の事ながらWeb Serverとして提供することになる。周知の通り、Goの場合は<code>net/http</code>を使って簡単にWeb Server Applicationを作ることが出来る。</p>

<pre><code class="go">package main

import (
    "fmt"
    "html"
    "log"
    "net/http"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
    })

    log.Fatal(http.ListenAndServe(":8080", nil))
}
</code></pre>

<p>上記のソースコードはGo Web Applicationのテンプレートと言っても過言ではないので、スニペットなどに登録しておくと良い。</p>

<p>さて、上記のコードは以下のコマンドでプログラムとして起動させることができる。</p>

<pre><code class="shell">$ go run main.go
</code></pre>

<p>起動後、もう1つターミナルを開いて以下のように<code>curl</code>でアクセスすると、レスポンスが返ってきてWeb Serverとして動作していることが確認できる。</p>

<pre><code class="shell">$ curl -vvv localhost:8080/hello/world
*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
&gt; GET /hello/world HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.43.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Sat, 12 Mar 2016 10:51:45 GMT
&lt; Content-Length: 21
&lt; Content-Type: text/plain; charset=utf-8
&lt;
* Connection #0 to host localhost left intact
Hello, "/hello/world"
</code></pre>

<a name="Adding.a.Router"></a>
<h2>Adding a Router</h2>

<p>通常、APIには複数の処理を実装し、各処理に応じたURLを割り当てる。このような<em>routing</em>の実装を行うためのライブラリは標準で提供されているが、一般的には<a href="https://github.com/gorilla/mux">gorilla/mux</a>か<a href="https://github.com/julienschmidt/httprouter">julienschmidt/httprouter</a>が使われていることが多い。元記事は前者のgorilla/muxを使っているが、今回はjulienschmidt/httprouterを使うことにする。</p>

<pre><code class="go">package main

import (
    "fmt"
    "html"
    "log"
    "net/http"

    "github.com/julienschmidt/httprouter"
)

func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
}

func main() {
    router := httprouter.New()
    router.GET("/:path", Index)

    log.Fatal(http.ListenAndServe(":8080", router))
}
</code></pre>

<p>httprouterのroutingは結構厳密なので、元記事とはやや異なるソースとなる。具体的には<code>router.GET("/:path", Index)</code>としているところ。こうしないと、例えば<code>localhost:8080/hello_world</code>としたときに<code>Index</code>ハンドラへ処理が流れていかない。また、<code>router.GET("/", Index)</code>とすると、<code>localhost:8080/</code>あるいは<code>localhost:8080</code>とリクエストする必要があるため。</p>

<p>さて、上記のコードでは外部パッケージを利用しているので、プログラムを起動する前に以下のようにしてパッケージをインストールする必要がある。</p>

<pre><code class="shell">$ go get "github.com/julienschmidt/httprouter"
</code></pre>

<p>インストール後、プログラムを起動すると、以下のようにして動作を確認することができる。</p>

<pre><code class="shell">$ curl -vvv localhost:8080/hello_world
*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
&gt; GET /hello_world HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.43.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Sat, 12 Mar 2016 11:16:22 GMT
&lt; Content-Length: 21
&lt; Content-Type: text/plain; charset=utf-8
&lt;
* Connection #0 to host localhost left intact
Hello, "/hello_world"
</code></pre>

<a name="Creating.Some.Basic.Routes"></a>
<h2>Creating Some Basic Routes</h2>

<p>httprouterの基本的な使い方を把握したので、それっぽくいくつかroutingを実装する。元記事に倣い、ToDoアプリケーションを作ると想定してみると、以下のようなコードになる。</p>

<pre><code class="go">package main

import (
    "fmt"
    "log"
    "net/http"

    "github.com/julienschmidt/httprouter"
)

func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    fmt.Fprintf(w, "Welcmoe!")
}

func TodoIndex(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    fmt.Fprintf(w, "Todo Index!")
}

func TodoShow(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    fmt.Fprintf(w, "Todo show: %s", ps.ByName("todoId"))
}

func main() {
    router := httprouter.New()
    router.GET("/", Index)
    router.GET("/todos", TodoIndex)
    router.GET("/todos/:todoId", TodoShow)

    log.Fatal(http.ListenAndServe(":8080", router))
}
</code></pre>

<p>見ての通り、2つのエンドポイント(あるいはルート)が追加されている。</p>

<ul>
<li>localhost:8080/todos

<ul>
<li>Todoの一覧を表示するルート</li>
</ul>
</li>
<li>localhost:8080/todos/:todoId

<ul>
<li><code>:todoId</code>で指定したTodoの項目を表示するルート</li>
</ul>
</li>
</ul>


<p>すでに触れているが、ここでは<code>:todoId</code>をURL指定の中に追加している。こうすることによって、例えば<code>localhost:8080/todos/123</code>とリクエストしたときに<code>123</code>という文字列が<code>todoId</code>に割り当てられることになる。割り当てられた<code>todoId</code>は<code>ps.ByName()</code>という関数を使って取り出すことができる。</p>

<p>今回はcurlでの実行例を省略する。</p>

<a name="A.Basic.Model"></a>
<h2>A Basic Model</h2>

<p>次にこのプログラムで取り扱うデータのモデルを定義する。Goの場合は<code>struct</code>を使って定義するのが一般的だ。他の言語であれば<code>class</code>で定義することが一般的かもしれない。ちなみに、<code>map</code>を使うことで定義の宣言を（ある程度）省略することが可能だが、Goでは<code>map</code>はスレッドセーフではなく、goroutineなどを使ってconcurrentに処理を行うことが多い処理では慎重に使う必要があるため、個人的には<code>map</code>を使うのはオススメしない(参考: <a href="https://golang.org/doc/faq#atomic_maps">Why are map operations not defined to be atomic?</a>)。</p>

<pre><code class="go">package main

import (
    "fmt"
    "log"
    "net/http"
    "time"

    "github.com/julienschmidt/httprouter"
)

type Todo struct {
    Name      string    `json:"name"`
    Completed bool      `json:"completed"`
    Due       time.Time `json:"due"`
}

type Todos []Todo

// 以降は上掲のコードと同じなので省略する
</code></pre>

<p><code>type Todos []Todo</code>では<code>struct</code>を使って宣言していないが、直観的に<code>Todo</code>のスライスだとわかるはず。また、今回はJSON形式でレスポンスを返すと予めわかっているのでstructのプロパティにjsonタグをつけている。</p>

<a name="Send.Back.Some.JSON"></a>
<h2>Send Back Some JSON</h2>

<p>データモデルを定義したので、このデータモデルの使い方を確認する。使い方の部分だけを抜粋すると、以下のようになる。</p>

<pre><code class="go">func TodoIndex(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    todos := Todos{
        Todo{Name: "Write presentation"},
        Todo{Name: "Host meetup"},
    }

    json.NewEncoder(w).Encode(todos)
}
</code></pre>

<p>上記を追加して（もちろん<code>import "encoding/json"</code>も忘れずに）、プログラムを起動してレスポンスを確認してみる。ここでは出力を整形するために<a href="https://stedolan.github.io/jq/">jq</a>を使っている。</p>

<pre><code class="shell">$ curl --silent localhost:8080/todos | jq
[
  {
    "name": "Write presentation",
    "completed": false,
    "due": "0001-01-01T00:00:00Z"
  },
  {
    "name": "Host meetup",
    "completed": false,
    "due": "0001-01-01T00:00:00Z"
  }
]
</code></pre>

<p>上記では、<code>Completed</code>と<code>Due</code>にそれぞれ値を割り当てていないので、初期値が出力されている。また、元記事とは微妙に室力がプロパティのキー値が異なっている。これは先述したJSONタグでの定義によるもの。</p>

<a name="A.Better.Model"></a>
<h2>A Better Model</h2>

<p>すでに上記で触れているので省略。</p>

<a name="OK..We.Need.to.Split.This.Up."></a>
<h2>OK, We Need to Split This Up!</h2>

<p>この時点ではソースコードは50行弱だが、若干のリファクタリングを行う。具体的には以下のファイル群に処理を分ける。元記事とは異なり、<code>routes.go</code>は無い。なんかあんまり実用性があるように思えなかったので。httprouterだと同じような実装ができないからっていうのもあるけど。なお、このようにファイルを分割した場合は<code>go get</code>で起動するよりも一度<code>go build</code>して実行バイナリを生成してから動作確認をしたほうがハマりにくい。</p>

<ul>
<li>main.go</li>
<li>handlers.go</li>
<li>todo.go</li>
</ul>


<a name="main.go"></a>
<h3>main.go</h3>

<pre><code class="go">package main

import (
    "log"
    "net/http"

    "github.com/julienschmidt/httprouter"
)

func main() {
    router := httprouter.New()
    router.GET("/", Index)
    router.GET("/todos", TodoIndex)
    router.GET("/todos/:todoId", TodoShow)

    log.Fatal(http.ListenAndServe(":8080", router))
}
</code></pre>

<a name="handlers.go"></a>
<h3>handlers.go</h3>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
    "net/http"

    "github.com/julienschmidt/httprouter"
)

func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    fmt.Fprintf(w, "Welcmoe!")
}

func TodoIndex(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    todos := Todos{
        Todo{Name: "Write presentation"},
        Todo{Name: "Host meetup"},
    }

    if err := json.NewEncoder(w).Encode(todos); err != nil {
        panic(err)
    }
}

func TodoShow(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    fmt.Fprintf(w, "Todo show: %s", ps.ByName("todoId"))
}
</code></pre>

<a name="todo.go"></a>
<h3>todo.go</h3>

<pre><code class="go">package main

import "time"

type Todo struct {
    Name      string    `json:"name"`
    Completed bool      `json:"completed"`
    Due       time.Time `json:"due"`
}

type Todos []Todo
</code></pre>

<a name="Even.Better.Routing"></a>
<h2>Even Better Routing</h2>

<p>元記事ではroutingの設定をstructとしてデータモデル化することでより良いルーティングができるよ！っと言っている（と理解した）。今回はスキップ。</p>

<a name="Outputting.a.Web.Log"></a>
<h2>Outputting a Web Log</h2>

<p>Web Applicationのロギングについて。元記事では独自にロガーを実装している。httprouterではこのような共通関数の仕組みを<em>Middleware</em>として実装できる仕組みを提供している。元記事と同じような実装を以下のようにした。</p>

<a name="logger.go"></a>
<h3>logger.go</h3>

<p>基本的な考え方として、Middlewareは各URLへのリクエストに対して行う処理をハンドラとして受け取り、受け取ったハンドラを実行する前または後に処理を記述すればよい。よって、MiddlewareはハンドラとMiddlewareが必要とする情報を引数として受け取るだけで良い。</p>

<pre><code class="go">package main

import (
    "log"
    "net/http"
    "time"

    "github.com/julienschmidt/httprouter"
)

var logger = func(method, uri, name string, start time.Time) {
    log.Printf("\"method\":%q   \"uri\":%q  \"name\":%q \"time\":%q", method, uri, name, time.Since(start))
}

func Logging(h httprouter.Handle, name string) httprouter.Handle {
    return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
        start := time.Now()
        h(w, r, ps)
        logger(r.Method, r.URL.Path, name, start)
    }
}
</code></pre>

<p>Middlewareの実装例としては以下を参考にすること。</p>

<ul>
<li><a href="https://github.com/julienschmidt/httprouter#multi-domain--sub-domains">Multi-domain / Sub-domains</a></li>
<li><a href="https://github.com/julienschmidt/httprouter#multi-domain--sub-domains">Basic Authentication</a></li>
<li><a href="https://justinas.org/writing-http-middleware-in-go/">Writing HTTP Middleware in Go</a></li>
</ul>


<a name="Applying.the.Logger.Decorator"></a>
<h2>Applying the Logger Decorator</h2>

<p>上掲の<code>logger.go</code>を組み込むには単純に以下のようにすれば良い。</p>

<a name="main.go"></a>
<h3>main.go</h3>

<pre><code class="go">    router.GET("/", Logging(Index, "index"))
    router.GET("/todos", Logging(TodoIndex, "todo-index"))
    router.GET("/todos/:todoId", Logging(TodoShow, "todo-show"))
</code></pre>

<a name="This.Routes.File.is.Crazy.....Let...s.Refactor"></a>
<h2>This Routes File is Crazy … Let’s Refactor</h2>

<p>スキップ。</p>

<a name="Taking.Some.Responsibility"></a>
<h2>Taking Some Responsibility</h2>

<p>これでようやく今回のアプリケーションのボイラーテンプレートが出来たので、各ハンドラをWeb Applicationっぽくしていく。まずは<code>TodoIndex</code>のレスポンスを改善する。現在の状態でレスポンスを詳細に見てみる(curlのオプションに<code>-vvv</code>または<code>-D -</code>というオブションをつけて実行する)と、以下のように出力されているはず。</p>

<pre><code class="shell">$ curl --silent localhost:8080/todos -vvv
*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
&gt; GET /todos HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.43.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Sat, 12 Mar 2016 13:44:09 GMT
&lt; Content-Length: 149
&lt; Content-Type: text/plain; charset=utf-8  ## &lt;- コレに注目
&lt;
[{"name":"Write presentation","completed":false,"due":"0001-01-01T00:00:00Z"},{"name":"Host meetup","completed":false,"due":"0001-01-01T00:00:00Z"}]
* Connection #0 to host localhost left intact
</code></pre>

<p>レスポンスのContent-Typeが<code>text/plain; charset=utf-8</code>となっているのが確認できる。今回はJSON APIを作るのが目的なので、<code>application/json; charset=UTF-8</code>としてレスポンスを返したい。なので、以下のようにコードを少し追加する。</p>

<pre><code class="go">func TodoIndex(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    todos := Todos{
        Todo{Name: "Write presentation"},
        Todo{Name: "Host meetup"},
    }

    w.Header().Set("Content-Type", "application/json; charset=UTF-8") // &lt;- Added
    w.WriteHeader(http.StatusOK) // &lt;- Added

    if err := json.NewEncoder(w).Encode(todos); err != nil {
        panic(err)
    }
}
</code></pre>

<p><code>// &lt;- Added</code>とコメントしている行が追加されている。直観的にわかると思うけど、レスポンスヘッダにContent-Typeとステータスコードを設定しているだけ。buildしなおしてからcurlでアクセスしてみる。</p>

<pre><code class="shell">*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
&gt; GET /todos HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.43.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Content-Type: application/json; charset=UTF-8  ## &lt;- コレに注目
&lt; Date: Sat, 12 Mar 2016 13:52:46 GMT
&lt; Content-Length: 149
&lt;
[{"name":"Write presentation","completed":false,"due":"0001-01-01T00:00:00Z"},{"name":"Host meetup","completed":false,"due":"0001-01-01T00:00:00Z"}]
* Connection #0 to host localhost left intact
</code></pre>

<p>レスポンスヘッダが意図したものになっていることが確認できる。</p>

<a name="Wait..Where.is.my.Database."></a>
<h2>Wait, Where is my Database?</h2>

<p>Web Applicationにデータベースはつきもの。ここでは簡易なモックデータベースを使ってデータベースを使った処理を仮実装してみる。</p>

<a name="repo.go"></a>
<h3>repo.go</h3>

<p>モックデータベースの処理は<code>repo.go</code>に記述することにする。ここでは擬似的なCreate/Read/Delete処理を実装している。</p>

<pre><code class="go">package main

import "fmt"

var (
    todos     Todos
    currentID int
)

func init() {
    RepoCreateTodo(Todo{Name: "Write presentation"})
    RepoCreateTodo(Todo{Name: "Host meetup"})
}

func RepoFindTodo(id int) Todo {
    for _, t := range todos {
        if t.ID == id {
            return t
        }
    }
    return Todo{}
}

func RepoCreateTodo(t Todo) Todo {
    currentID += 1
    t.ID = currentID
    todos = append(todos, t)
    return t
}

func RepoDestroyTodo(id int) error {
    for i, t := range todos {
        if t.ID == id {
            todos = append(todos[:i], todos[i+1:]...)
            return nil
        }
    }

    return fmt.Errorf("Could not find Todo with id of %d to delete", id)
}
</code></pre>

<a name="Add.ID.to.Todo"></a>
<h2>Add ID to Todo</h2>

<p><code>repo.go</code>ではTodoの項目を探すために<code>ID</code>という概念を利用しているので、データモデルに<code>ID</code>を追加しておく。</p>

<pre><code class="go">package main

import "time"

type Todo struct {
    ID        int       `json:"id"`
    Name      string    `json:"name"`
    Completed bool      `json:"completed"`
    Due       time.Time `json:"due"`
}

type Todos []Todo
</code></pre>

<a name="Update.our.TodoIndex"></a>
<h2>Update our TodoIndex</h2>

<p><code>repo.go</code>の<code>init.go</code>にて初期値を与えるようにし、また、<code>todos</code>はグローバル変数として利用できるようになった（本当は良くない）ので<code>handlers.go</code>の<code>TodoIndex</code>を以下のように修正する。</p>

<pre><code class="go">func TodoIndex(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    w.Header().Set("Content-Type", "application/json; charset=UTF-8")
    w.WriteHeader(http.StatusOK)

    if err := json.NewEncoder(w).Encode(todos); err != nil {
        panic(err)
    }
}
</code></pre>

<a name="Posting.JSON"></a>
<h2>Posting JSON</h2>

<p>スキップ</p>

<a name="The.Create.endpoint"></a>
<h2>The Create endpoint</h2>

<p>モックデータベースの処理を実装したので、それを利用するエンドポイントを追加する。なお、元記事では<code>RepoCreateTodo</code>を使ったエンドポイントのみを実装しているが、せっかくなので<code>RepoFindTodo</code>と<code>RepoDestroyTodo</code>を使ったエンドポイントも実装する。</p>

<a name="TodoShow"></a>
<h3>TodoShow</h3>

<p>まずは<code>TodoShow</code>から。<code>ps.ByName</code>で対象のIDを受け取りバリデーションを兼ねて<code>strconv.Atoi</code>で変換する。変換したIDが数字でなければ422を返す。知らなかったけど、このようなリクエストの形式としては正しいが意味的に間違っている場合（今回の場合だと数字であるべき箇所に数値(int)に変換できない文字列を含む場合）は<code>422 Unprocessable Entity</code>を返すのが一般的らしい。変換したIDを<code>RepoFindTodo</code>に渡して結果をもらう。空っぽだったら404、何か入っていれば200を返す。</p>

<pre><code class="go">func TodoShow(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    idParam := ps.ByName("todoId")
    id, err := strconv.Atoi(idParam)
    if err != nil {
        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.WriteHeader(422) // unprocessable entity
        if err := json.NewEncoder(w).Encode(err); err != nil {
            panic(err)
        }
        return
    }

    t := RepoFindTodo(id)
    if t.ID == 0 &amp;&amp; t.Name == "" {
        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.WriteHeader(http.StatusNotFound)
        return
    }

    w.Header().Set("Content-Type", "application/json; charset=UTF-8")
    w.WriteHeader(http.StatusOK)
    if err := json.NewEncoder(w).Encode(t); err != nil {
        panic(err)
    }
    return
}
</code></pre>

<a name="TodoCreate"></a>
<h3>TodoCreate</h3>

<p><code>TodoCreate</code>は元記事とほとんど同じだけど、RESTful APIっぽくするために<code>Location</code>をヘッダーに追加している。元記事でも触れているが、<code>io.LimitReader(r.Body, 1048576)</code>は巨大なリクエストを受け取らないようにするため。<code>1048576</code>は1MiB(<a href="https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%93%E3%83%90%E3%82%A4%E3%83%88">メビバイト</a>)。これもまた知らなかったけど、最近はこっちのほうがモダンなのかな。</p>

<pre><code class="go">func TodoCreate(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    var todo Todo

    body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576)) // 1MiB
    if err != nil {
        panic(err)
    }
    defer r.Body.Close()

    if err := json.Unmarshal(body, &amp;todo); err != nil {
        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.WriteHeader(500)
        if err := json.NewEncoder(w).Encode(err); err != nil {
            panic(err)
        }
        return
    }

    t := RepoCreateTodo(todo)
    location := fmt.Sprintf("http://%s/%d", r.Host, t.ID)
    w.Header().Set("Content-Type", "application/json; charset=UTF-8")
    w.Header().Set("Location", location)
    w.WriteHeader(http.StatusCreated)
    if err := json.NewEncoder(w).Encode(t); err != nil {
        panic(err)
    }
    return
}
</code></pre>

<a name="TodoDelete"></a>
<h3>TodoDelete</h3>

<p>実は<code>DELETE</code>メソッドの処理を作ったことがなかった。というか、Web Applicationを作る機会自体があんまり無いんだけど。削除の場合、特に返却すべき内容は無いので、<code>204 Not Content</code>を返している。</p>

<pre><code class="go">func TodoDelete(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    idParam := ps.ByName("todoId")
    id, err := strconv.Atoi(idParam)
    if err != nil {
        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.WriteHeader(500)
        if err := json.NewEncoder(w).Encode(err); err != nil {
            panic(err)
        }
        return
    }

    if err := RepoDestroyTodo(id); err != nil {
        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.WriteHeader(http.StatusNotFound)
        if err := json.NewEncoder(w).Encode(err); err != nil {
            panic(err)
        }
        return
    }

    w.WriteHeader(204) // 204 No Content
    return
}
</code></pre>

<a name="Things.We.Didn...t.Do"></a>
<h2>Things We Didn’t Do</h2>

<ul>
<li>Version Control

<ul>
<li>gitとかの話ではなくAPIとしてのバージョンのこと。例えば互換性を破壊するような変更を行うことが予想される場合は、<code>/api/v1/prefix</code>のようなエンドポイントで設定したほうが良いかもしれない。</li>
</ul>
</li>
<li>Authentication

<ul>
<li>パブリックあるいはオープンなAPIで無いのならば、認証は設けたほうが良い。元記事では<a href="http://jwt.io/">JSON web tokens</a>の利用を推奨している。</li>
</ul>
</li>
</ul>


<p>また、元記事では<a href="https://ja.wikipedia.org/wiki/HTTP_ETag">eTags</a>を使ってキャッシュの仕組みを盛り込み、スケーリング可能なアプリケーションの実装を提案している。具体的な実装については以下が参考になりそう（ちゃんと読んでない）。</p>

<ul>
<li><a href="http://www.sanarias.com/blog/115LearningHTTPcachinginGo">Learning HTTP caching in Go</a>

<ul>
<li><a href="https://www.reddit.com/r/golang/comments/2sxlwp/learning_http_caching_in_go/">Redditのスレ</a></li>
</ul>
</li>
<li><a href="http://stackoverflow.com/q/23014106">HTTP ETags and HTTP Redirects</a></li>
</ul>


<a name="What.Else.is.Left."></a>
<h2>What Else is Left?</h2>

<p>他にやるべきこととしては以下が挙げられる。</p>

<ul>
<li>リファクタリング</li>
<li>各々の処理をファイルをパッケージに分割する</li>
<li>テスト</li>
<li>適切なエラーメッセージ

<ul>
<li>これは独自に追加した項目なんだけど、例えば今は<code>strconv.Atoi</code>でエラーが発生した場合にエラーをそのままクライアントにかえしているので、これはやはり適切なエラーメッセージに変えたほうが良い。</li>
</ul>
</li>
</ul>


<a name="L.............-....................................."></a>
<h2>おまけ１ - 同じような処理をまとめる</h2>

<p>ハンドラの処理を実装している<code>handlers.go</code>を眺めていると気づくが、ハンドラの処理の構成は主に以下のようになっている。</p>

<ul>
<li>事前処理: 引数のバリデーションチェック</li>
<li>主処理: モックデータベースを使った処理</li>
<li>事後処理: レスポンスヘッダーと返却するHTTPステータスコードの設定</li>
</ul>


<p>主処理は事前処理にてチェックされた値を受け取るという若干の依存はあるものの、それぞれの関心事は以下のように分けることが出来て、それぞれ分離させて共通化出来そうなことに気づく。</p>

<ul>
<li>事前処理: クライアントからのリクエストの中身に興味がある</li>
<li>主処理: 指定されたTodoのIDを使ったデータベースの操作に興味がある</li>
<li>事後処理: クライアントに返却するレスポンスに興味がある</li>
</ul>


<p>ここでロギング処理をMiddlewareとして実装したことを思い出す。今回の事前処理と事後処理もロギングと同様にMiddlewareとして実装することでコードの重複を減らし、ハンドラの関心事を主処理に専念させることができそうだ。</p>

<a name="decorator.go"></a>
<h3>decorator.go</h3>

<p>事前処理と事後処理を記述する<code>decorator.go</code>というファイルを用意する。やるべきことは<code>handlers.go</code>に記述していた処理をコピペするだけ。多少修正しているが、以下のようになる。</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "net/http"
    "strconv"

    "github.com/julienschmidt/httprouter"
)

func IDShouldBeInt(h httprouter.Handle, name string) httprouter.Handle {
    return CommonHeaders(func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
        idParam := ps.ByName("todoId")
        _, err := strconv.Atoi(idParam)
        if err != nil {
            w.Header().Set("Content-Type", "application/json; charset=UTF-8")
            w.WriteHeader(500)
            if err := json.NewEncoder(w).Encode(err); err != nil {
                return
            }
            return
        }

        h(w, r, ps)
    }, name)
}

func CommonHeaders(h httprouter.Handle, name string) httprouter.Handle {
    return Logging(func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
        w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        h(w, r, ps)
    }, name)
}
</code></pre>

<p><code>_, err := strconv.Atoi(idParam)</code>では変換された値を捨てている。これは事前処理では変換された値を使わないから。また、見ての通り、ソースのシグネチャというか、基本的な構造は<code>logger.go</code>で実装したものと何も変わらないことに気づくはず。非常にシンプルにコードが書けているし、関数の処理内容もわかりやすくなったと思う。</p>

<p>ただ、これで良いかと言われると、やや苦しいところがある。それは事前処理の中でレスポンスを返却しているところだ。処理の内容からしてここではパラメータが不正であることだけを呼び出し元に通知して良い感じに事後処理に結果を渡すことができればよいのだけど、今の時点では妥協しておく（というか良いやり方を思いつかなかった）。</p>

<a name="handlers.go"></a>
<h3>handlers.go</h3>

<p>上記の通り、事前処理と事後処理をハンドラから取り除いたので<code>handlers.go</code>は以下のようになる。</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
    "io"
    "io/ioutil"
    "net/http"
    "strconv"

    "github.com/julienschmidt/httprouter"
)

func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    fmt.Fprintf(w, "Welcmoe!")
}

func TodoIndex(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    w.WriteHeader(http.StatusOK)

    if err := json.NewEncoder(w).Encode(todos); err != nil {
        panic(err)
    }
}

func TodoShow(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    id, _ := strconv.Atoi(ps.ByName("todoId"))
    t := RepoFindTodo(id)
    if t.ID == 0 &amp;&amp; t.Name == "" {
        w.WriteHeader(http.StatusNotFound)
        return
    }

    w.WriteHeader(http.StatusOK)
    if err := json.NewEncoder(w).Encode(t); err != nil {
        panic(err)
    }
}

func TodoCreate(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    var todo Todo

    body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576)) // 1MiB
    if err != nil {
        panic(err)
    }
    defer r.Body.Close()

    if err := json.Unmarshal(body, &amp;todo); err != nil {
        w.WriteHeader(500)
        if err := json.NewEncoder(w).Encode(err); err != nil {
            panic(err)
        }
        return
    }

    t := RepoCreateTodo(todo)
    location := fmt.Sprintf("http://%s/%d", r.Host, t.ID)
    w.Header().Set("Location", location)
    w.WriteHeader(http.StatusCreated)
    if err := json.NewEncoder(w).Encode(t); err != nil {
        panic(err)
    }
}

func TodoDelete(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    id, _ := strconv.Atoi(ps.ByName("todoId"))
    if err := RepoDestroyTodo(id); err != nil {
        w.WriteHeader(http.StatusNotFound)
        if err := json.NewEncoder(w).Encode(err); err != nil {
            panic(err)
        }
        return
    }

    w.Header().Del("Content-Type")
    w.WriteHeader(204) // 204 No Content
}
</code></pre>

<p>ちょっとすっきりしたけど、処理結果に応じてHTTPステータスコードが変わるため今の時点では主処理から取り除くことが出来ないので、ちょっと中途半端になっている。</p>

<a name="main.go"></a>
<h3>main.go</h3>

<p>それぞれの主処理に応じて用意したMiddlewareを割り当てる。多少は可読性が上がったかも？</p>

<pre><code class="go">package main

import (
    "log"
    "net/http"

    "github.com/julienschmidt/httprouter"
)

func main() {
    router := httprouter.New()
    router.GET("/", Logging(Index, "index"))
    router.GET("/todos", CommonHeaders(TodoIndex, "todo-index"))
    router.GET("/todos/:todoId", IDShouldBeInt(TodoShow, "todo-show"))
    router.POST("/todos", CommonHeaders(TodoCreate, "todo-create"))
    router.DELETE("/todos/:todoId", IDShouldBeInt(TodoDelete, "todo-delete"))

    log.Fatal(http.ListenAndServe(":8080", router))
}
</code></pre>

<a name="L........................"></a>
<h2>ここまでのまとめ</h2>

<p>ある程度はそれらしくなったけど、主処理の中でレスポンスヘッダ―を設定していたりするため現状ではやや不満が残る内容になった。これは主処理と事後処理が完全に分断されているためであり次回はその辺りを考慮に入れてリファクタリングを行なう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自分で定義したprimitiveな型を扱う際の注意点]]></title>
    <link href="http://sgykfjsm.github.io/blog/2016/01/25/working-with-userdefined-type/"/>
    <updated>2016-01-25T01:11:59+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2016/01/25/working-with-userdefined-type</id>
    <content type="html"><![CDATA[<p>Goではよく知られているように自分で型(type)を宣言して、任意のfunctionを実装することができる。今回、あるプログラムを実装している時に少しハマったので、経緯と対応策を記録しておく。</p>

<!-- more -->


<a name="L........................"></a>
<h2>ありがち？な失敗</h2>

<p>先述したようにGoでは任意の型を定義して、任意のfunctionを実装できる。タイトルにある<em>自分で定義したprimitiveな型</em>とは以下の様な宣言のこと。</p>

<pre><code class="go">type MyInt int
</code></pre>

<p>例えばこの<code>MyInt</code>に、<em>10より大きければ<code>true</code>を返す</em><code>Over10()</code>を実装し、以下の様に使いたいとする。</p>

<pre><code class="go">func main() {
    var i MyInt = 11

    if i.Over10() {
        println(i, " is over 10")
    } else {
        println(i, " is less than or equal 10")
    }
}
</code></pre>

<p>ここで、何も考えずに実装してしまうと、以下の様なコードを書いてしまう。</p>

<pre><code class="go">func (m MyInt)Over10() bool {
    if m &gt; 10 {
        return true
    }
    return false
}
</code></pre>

<p>このfunctionをコンパイルすると、以下の様なエラーが発生する。</p>

<pre><code>prog.go:6: invalid operation: i &gt; 10 (mismatched types *MyInt and int)
</code></pre>

<ul>
<li><a href="https://play.golang.org/p/uwaedTOJZ1">https://play.golang.org/p/uwaedTOJZ1</a></li>
</ul>


<a name="L......"></a>
<h2>対策</h2>

<p>type <code>MyInt</code>はint型を基礎に持っているから普通に比較できるはずではと思ってしまうが、エラー文言にあるように、int型を基礎にしていても、intではなく<code>MyInt</code>型なのでintとして使うことはできない。ちょっと考えればわかることだ。</p>

<p>ではどうするか？今回の場合だと、対策としては2通りある。</p>

<ol>
<li>比較相手である<code>10</code>を<code>MyInt</code>型として利用する。</li>
<li>1.の逆で、<code>i MyInt</code>から値を取り出し、int型として扱う。</li>
</ol>


<a name="L.....................10...MyInt........................"></a>
<h3>比較相手である10をMyInt型として利用する</h3>

<pre><code>func (i MyInt) Over10() bool {
    var ten MyInt = 10
    if i &gt; ten {
        return true
    }
    return false
}
</code></pre>

<ul>
<li>実行例: <a href="https://play.golang.org/p/b17c7k4dxU">https://play.golang.org/p/b17c7k4dxU</a></li>
</ul>


<a name="i.MyInt...........................int.................."></a>
<h3>i MyIntから値を取り出し、int型として扱う</h3>

<p>この場合はちょっと面倒になる。というのも、<code>reflect</code>パッケージを使って、変数の型の情報を取得する必要があるからだ。</p>

<pre><code class="go">func (i MyInt) Over10() bool {
    v := reflect.ValueOf(i)
    var num int
    if v.IsValid() {
        num = int(v.Int())
    }

    if num &gt; 10 {
        return true
    }
    return false
}
</code></pre>

<ul>
<li>実行例: <a href="https://play.golang.org/p/6F3zU6Q4-g">https://play.golang.org/p/6F3zU6Q4-g</a></li>
</ul>


<p>まず、与えられた変数に値が入っているかどうかを確認し、入っていれば<code>Int()</code>で取り出す。<code>Int()</code>で取り出した値は<code>int64</code>なので、<code>int</code>に変換しなければならない。</p>

<p>毎回この処理を実装するfunctionに書くのは面倒なので、以下の様なfunctionを用意しておくと良い。</p>

<pre><code class="go">func (i MyInt)ValueInt() (num int) {
    v := reflect.ValueOf(i)
    if v.IsValid() {
        num = int(v.Int())
    }
    return
}
</code></pre>

<ul>
<li>実行例: <a href="https://play.golang.org/p/cMsyxf97aL">https://play.golang.org/p/cMsyxf97aL</a></li>
</ul>


<hr />

<p>primitiveな型を利用した型を定義するときには、少々面倒だが、上記の<code>ValueInt</code>を実装することを忘れないようにしたい。</p>

<p>しかし、実際、みんなこんな風に実装しているのだろうか。さすがに面倒すぎる気がするなぁ。本当はもっと良い方法があるんだろうか？本音としては、このくらい、compileとか<code>go generate</code>的な何かでで良い感じに対応していただきたいのだけど、そういうわけにはいかないのだろうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goでfunctionが実行された順番を追いかける]]></title>
    <link href="http://sgykfjsm.github.io/blog/2016/01/20/golang-function-tracing/"/>
    <updated>2016-01-20T00:33:25+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2016/01/20/golang-function-tracing</id>
    <content type="html"><![CDATA[<p>Goはgo routineを使って並行処理を容易に書くことができるが、下手に書くと色々なfunctionが相互に入り乱れて処理が追いづらいときがある。ここではGoでfunctionをトレースする方法をメモしておく。</p>

<!-- more -->


<p>結論から言えば、<code>runtime.Caller</code>を使えば良い。なお、<code>debug.PrintStack</code>でstack traceを出力することができるが、標準エラー出力となるのでちょっと使いづらい。しかし、ただコンソールで出力したいだけなら、<code>debug.PrintStack</code>のほうが簡単であるし、これ以降を読む必要は無い。</p>

<ul>
<li><a href="https://golang.org/pkg/runtime/#Caller">func Caller</a></li>
<li><a href="https://golang.org/pkg/runtime/debug/#PrintStack">func PrintStack</a></li>
</ul>


<a name="L.................."></a>
<h2>簡単な使い方</h2>

<p><code>runtime.Caller</code>とは何なのかはマニュアルを参照すべきだけど、簡単に言うと、引数の数値に応じて<code>Caller</code>が呼び出された時点での呼び出し元の情報を提供してくれるfunctionと言える。例えば、以下のような処理を想定してみる。</p>

<pre><code class="go">package main

import (
    "log"
    "runtime"
)

func doCaller() {
    programCounter, sourceFileName, sourceFileLineNum, ok := runtime.Caller(1)
    log.Printf("programCounter: %v\n", programCounter)
    log.Printf("souruntime: %s\n", sourceFileName)
    log.Printf("sourceFileLineNum: %d\n", sourceFileLineNum)
    log.Printf("ok: %t\n", ok)
}

func callCaller() {
    doCaller()
}

func main() {
    callCaller()
}
</code></pre>

<p><a href="https://play.golang.org/p/X_tDUvfR7s">https://play.golang.org/p/X_tDUvfR7s</a></p>

<p>上記の場合、処理は<code>main</code> -> <code>callCaller</code> -> <code>doCaller</code>の順で実行され、この順番で<em>goroutineのstack</em>にfunctionが積み上がる（正確には<code>main</code>の前に<code>runtime.main</code>と<code>runtime.goexit</code>が呼び出されているがここでは省略する）。<code>runtime.Caller</code>の引数は<code>skip int</code>と定義されているが、イメージとしては配列のインデックスみたいな感じで、stackの上から何番目の情報を取得するか、を指定することができる。上記の場合、<code>1</code>を指定しているので、<code>callCaller</code>の情報を取得することができる。結果は以下の通り。なんかタイムスタンプがおかしい気がするが、気にしない。</p>

<pre><code>2009/11/10 23:00:00 programCounter: 132352
2009/11/10 23:00:00 souruntime: /tmp/sandbox627002569/main.go
2009/11/10 23:00:00 sourceFileLineNum: 17
2009/11/10 23:00:00 ok: true
</code></pre>

<p>変数名から何となく推測できると思うけど、<code>runtime.Caller</code>の返り値の１つ目はプログラムカウンター、2つ目がビルドされたソースファイル名（実行ファイル名では無いことに注意）、3つ目はソースファイル内での呼びだされた位置、4つ目は情報が取得できたか否かを示すbooleanとなっている。</p>

<p>これだけだと、どの関数から呼ばれたか？がわからないので、もう少し処理を追加してみる。使うfunctionは<code>FuncForPC</code>だ。</p>

<ul>
<li><a href="https://golang.org/pkg/runtime/#FuncForPC">FuncForPC</a></li>
</ul>


<pre><code class="go">package main

import (
    "log"
    "runtime"
    "strings"
)

func doCaller() {
    programCounter, sourceFileName, sourceFileLineNum, ok := runtime.Caller(1)
    log.Printf("programCounter: %v\n", programCounter)
    log.Printf("souruntime: %s\n", sourceFileName)
    log.Printf("sourceFileLineNum: %d\n", sourceFileLineNum)
    log.Printf("ok: %t\n", ok)

    println("-----")

    fn := runtime.FuncForPC(programCounter)
    log.Printf("Function Name: %s\n", fn.Name())
    fileName, fileLine := fn.FileLine(programCounter)
    log.Printf("FileName:%s, FileLine: %d\n", fileName, fileLine)

    splitedFnName := strings.Split(fn.Name(), ".")
    packageName := splitedFnName[0]
    callerFuncName := splitedFnName[1]
    log.Printf("packageName: %s\n", packageName)
    log.Printf("functionName: %s\n", callerFuncName)

}

func callCaller() {
    doCaller()
}

func main() {
    callCaller()
}
</code></pre>

<p><a href="https://play.golang.org/p/sFMnwYTHYF">https://play.golang.org/p/sFMnwYTHYF</a></p>

<p>結果は以下の通り。</p>

<pre><code>2009/11/10 23:00:00 programCounter: 134432
2009/11/10 23:00:00 souruntime: /tmp/sandbox246241909/main.go
2009/11/10 23:00:00 sourceFileLineNum: 32
2009/11/10 23:00:00 ok: true
-----
2009/11/10 23:00:00 Function Name: main.callCaller
2009/11/10 23:00:00 FileName:/tmp/sandbox246241909/main.go, FileLine: 33
2009/11/10 23:00:00 packageName: main
2009/11/10 23:00:00 functionName: callCaller
</code></pre>

<p><code>FuncForPC</code>は引数で受け取ったプログラムカウンターの詳細な情報を返してくれる。見ての通り、<code>Caller</code>で取得したプログラムカンターから呼び出し元のfunction名、ファイル情報諸々を取得することができる。</p>

<p>このように、<code>Caller</code>と<code>FuncForPC</code>を使うことで、ある関数がどこから呼び出されたのかを知ることができる。</p>

<a name="L......1........................"></a>
<h2>もう1歩踏み込んでみる</h2>

<p>実際にデバッグする際には、最初のエントリーポイントからエラーが発生したfunctionまでを順に辿りたいことある。上記の<code>doCaller</code>を全ての関数に<code>defer</code>で登録しておけば出来なくはないが、そんなことはしたくないはず。通常は<code>log.Fatal</code>などでプログラムを終了させる直前とかに呼び出し情報を取得できるようにしておきたいはず。要は呼び出し情報をまとめて取得して、良い感じに扱いたいのだ。</p>

<p>とても安直な発想だが、<code>Caller</code>の引数を1つずつインクリメントしてたどる方法をここでは試してみる。例えば以下の様な感じ。</p>

<pre><code class="go">package main

import (
    "fmt"
    "regexp"
    "runtime"
)

var (
    re = regexp.MustCompile(`^(\S.+)\.(\S.+)$`)
)

type CallerInfo struct {
    PackageName  string
    FunctionName string
    FileName     string
    FileLine     int
}

func Dump() (callerInfo []*CallerInfo) {
    for i := 1; ; i++ {
        pc, _, _, ok := runtime.Caller(i) // https://golang.org/pkg/runtime/#Caller
        if !ok {
            break
        }

        fn := runtime.FuncForPC(pc)
        fileName, fileLine := fn.FileLine(pc)

        _fn := re.FindStringSubmatch(fn.Name())
        callerInfo = append(callerInfo, &amp;CallerInfo{
            PackageName:  _fn[1],
            FunctionName: _fn[2],
            FileName:     fileName,
            FileLine:     fileLine,
        })
    }
    return
}

func foo() {
    info := Dump()
    for i := len(info) - 1; i &gt; -1; i-- {
        v := info[i]
        fmt.Printf("%02d: %s.%s@%s:%d\n", i, v.PackageName, v.FunctionName, v.FileName, v.FileLine)
    }
}

func bar() {
    foo()
}

func main() {
    bar()
}
</code></pre>

<p><a href="https://play.golang.org/p/iED00tQ9EW">https://play.golang.org/p/iED00tQ9EW</a></p>

<p>上記を実行すると、以下の様にスタックの下から、つまりfunctionが実行された順番に表示される。</p>

<pre><code>04: runtime.goexit@/usr/local/go/src/runtime/asm_amd64p32.s:1133
03: runtime.main@/usr/local/go/src/runtime/proc.go:120
02: main.main@/tmp/sandbox266928852/main.go:55
01: main.bar@/tmp/sandbox266928852/main.go:51
00: main.foo@/tmp/sandbox266928852/main.go:42
</code></pre>

<a name="L......"></a>
<h2>余談</h2>

<p><code>Caller</code>は<em>goroutineのstackに積み上げられた情報</em>を出力するため、対象の処理に<code>go xxx()</code>や<code>go func</code>が含まれていると、上記のように必ずしも<code>runtime.goexit</code>-><code>runtime.main</code>の順番で始まるとは限らないことに注意すること。例えば、以下の様な感じ。</p>

<pre><code class="go">func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        bar()
        wg.Done()
    }()
    wg.Wait()
}
</code></pre>

<p><a href="https://play.golang.org/p/WZE3lItf8h">https://play.golang.org/p/WZE3lItf8h</a></p>

<p>上記の結果は以下の通りで、<code>runtime.main</code>が無いことがわかる。これは<code>go func</code>が<code>func main</code>とは異なるgoroutineで処理されていることを示している（と思う）。</p>

<pre><code>03: runtime.goexit@/usr/local/go/src/runtime/asm_amd64p32.s:1133
02: main.main.func1@/tmp/sandbox306261972/main.go:59
01: main.bar@/tmp/sandbox306261972/main.go:52
00: main.foo@/tmp/sandbox306261972/main.go:43
</code></pre>

<p>また、次の場合は同じ関数をclosureでラップせずにgoroutineとして起動した場合。</p>

<pre><code class="go">func main() {
    go bar()
    time.Sleep(1 * time.Second)
}
</code></pre>

<p><a href="https://play.golang.org/p/CcNp-Do9mb">https://play.golang.org/p/CcNp-Do9mb</a></p>

<p>結果は以下の様になる。</p>

<pre><code>02: runtime.goexit@/usr/local/go/src/runtime/asm_amd64p32.s:1133
01: main.bar@/tmp/sandbox385327178/main.go:52
00: main.foo@/tmp/sandbox385327178/main.go:43
</code></pre>

<p><code>go func</code>の場合と違って、closureを経由せずに、<code>bar</code>以降の処理を別のgoroutineとして起動させていることがわかる。</p>

<p>ちゃんとわかっている人からすれば当然のことに思われるだろうが、自分のようなGo初心者だと出力内容を見て、アレ？と思うかもしれないので、goroutineを使う処理のstack情報を取得する場合は注意すること。</p>
]]></content>
  </entry>
  
</feed>
