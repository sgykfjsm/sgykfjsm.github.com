<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | sgykfjsm.github.com]]></title>
  <link href="http://sgykfjsm.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://sgykfjsm.github.io/"/>
  <updated>2017-09-26T01:32:46+09:00</updated>
  <id>http://sgykfjsm.github.io/</id>
  <author>
    <name><![CDATA[sgykfjsm]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DjangoをTango with Djangoで学ぶ - 2 -]]></title>
    <link href="http://sgykfjsm.github.io/blog/2017/09/21/djangowotango-with-djangodexue-bu-2/"/>
    <updated>2017-09-21T00:19:39+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2017/09/21/djangowotango-with-djangodexue-bu-2</id>
    <content type="html"><![CDATA[<p><a href="http://sgykfjsm.github.io/blog/2017/09/07/djangowotango-with-djangodexue-bu-1/">DjangoをTango with Djangoで学ぶ - 1 -</a>の続き</p>

<p>これまでは表示するHTML（ただのテキストだけど）をviews.pyに直接記載していたが、Djangoでも他のWebフレームワークと同様にテンプレートシステムを備えている。</p>

<p>テンプレートシステムとは簡単に言うと、独自のシンタックスとHTMLを混ぜておきて、独自シンタックスの部分をサーバーサイドで指定された文字列などに置き換えたりすることだ。場合によっては多少の制御構文を備えており、ループ文やIF文を提供するテンプレートシステムも多い。</p>

<!-- more -->


<p>Djangoでテンプレートシステムを利用する場合、<code>${workspace}/tango_with_django_project/templates/${application}</code>というフォルダを作ればよい。今回の場合だと以下の様になる。</p>

<pre><code class="console">$ ls -la
total 20
drwxr-xr-x  9 sgyk   306  9  6 09:40 ./
drwxr-xr-x  9 sgyk   306  9  4 22:40 ../
drwxr-xr-x 12 sgyk   408  9  6 09:35 .git/
-rw-r--r--  1 sgyk  3329  9  4 23:09 .gitignore
drwxr-xr-x 12 sgyk   408  9  6 09:35 .idea/
-rw-r--r--  1 sgyk 12288  9  4 22:52 db.sqlite3
-rwxr-xr-x  1 sgyk   823  9  4 22:40 manage.py*
drwxr-xr-x 11 sgyk   374  9  4 23:50 rango/
drwxr-xr-x  8 sgyk   272  9  6 09:40 tango_with_django_project/

$ ls -la tango_with_django_project/
total 12
drwxr-xr-x 8 sgyk  272  9  6 09:40 ./
drwxr-xr-x 9 sgyk  306  9  6 09:40 ../
-rw-r--r-- 1 sgyk    0  9  4 22:40 __init__.py
drwxr-xr-x 6 sgyk  204  9  4 23:39 __pycache__/
-rw-r--r-- 1 sgyk 3166  9  4 23:10 settings.py
drwxr-xr-x 3 sgyk  102  9  6 09:40 templates/
-rw-r--r-- 1 sgyk  930  9  4 23:39 urls.py
-rw-r--r-- 1 sgyk  428  9  4 22:40 wsgi.py

$ ls -la tango_with_django_project/templates/
total 0
drwxr-xr-x 3 sgyk 102  9  6 09:40 ./
drwxr-xr-x 8 sgyk 272  9  6 09:40 ../
drwxr-xr-x 2 sgyk  68  9  6 09:40 rango/
</code></pre>

<p>次にDjangoに<code>tango_with_django_project/templates/rango</code>あるテンプレートを利用するということを教えてあげる必要がある。具体的には<code>tango_with_django_project/settings.py</code>に以下に設定を追加する必要がある。</p>

<pre><code class="python">...
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],  # &lt;-- ここにテンプレートのパスを追加する
        'APP_DIRS': True,
...
</code></pre>

<p>早速追加したいところだけど注意点がある。それは、<code>DIRS</code>に追加するパスは<strong>絶対パス</strong>でなければならないということだ。しかし、通常、開発時のテンプレートのパスとプロダクション環境で動作させるときに配置されるテンプレートのパスは異なるはず。異なる部分はワークスペース部分のパスになる。例えば、開発時は<code>/Users/you/workspace</code>がワークスペースかもしれないが、デプロイ時のパスは<code>/home/production/application</code>となるかもしれない。この違いの吸収するようにしないといけない。</p>

<p>もちろん、各環境ごとのパスを１つずつハードコーディングするのはダメである。一方、<code>tango_with_django_project/settings.py</code>をよく見てみると、次の１文に気づくはずだ。</p>

<pre><code class="python"># Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
</code></pre>

<p><code>BASE_DIR</code>は<code>tango_with_django_project/settings.py</code>の絶対パスを取得して、２つ上のディレクトリパスを取得している。もし<code>/Users/you/workspace/tango_with_django_project/settings.py</code>だとすると、<code>BASE_DIR</code>には<code>/Users/you/workspace</code>が格納される。</p>

<pre><code class="python">$ python
Python 3.5.3 (default, Sep  4 2017, 22:33:15)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.dirname(os.path.dirname("/Users/you/workspace/tango_with_django_project/settings.py"))
'/Users/you/workspace'
</code></pre>

<p>ということで、<code>/Users/you/workspace/tango_with_django_project/templates/rango</code>のようにパスをハードコートするのではなく、<code>BASE_DIR</code>を利用して以下の様に設定すれば良いことになる。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 8d38aa9..3b12343 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -52,10 +52,12 @@ MIDDLEWARE = [

 ROOT_URLCONF = 'tango_with_django_project.urls'

+TEMPLATE_DIR = os.path.join(BASE_DIR, 'templates')
+
 TEMPLATES = [
     {
         'BACKEND': 'django.template.backends.django.DjangoTemplates',
-        'DIRS': [],
+        'DIRS': [TEMPLATE_DIR, ],
         'APP_DIRS': True,
         'OPTIONS': {
             'context_processors': [
</code></pre>

<p>テンプレートの場所の設定が済んだので実際にテンプレートファイルを記述していく。ここでは以下のようなファイルを<code>rango/templates/index.html</code>として用意する。</p>

<p>templates/rango/index.html</p>

<p>&#8220;`html
&lt;!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rango says&hellip;</title>
</head>
<body></p>

<h1>Rango says&#8230;</h1>


<div>
  hey there parther!<br />
  <strong></strong><br />
</div>


<div>
  <a href="http://sgykfjsm.github.io/rango/about/">About</a>
</div>


<p></body>
</html>
&#8220;`</p>

<p>ほとんどはただのHTMLファイルだが、<code></code>をプレースホルダーとして設定している。AnsibleやJinja2などを経験しているならわかるが、このプレースホルダーがサーバーサイドで任意の変数に置き換えられる。</p>

<p>次にレンダリング処理を記述する。記述する箇所はもちろん<code>rango/views.py</code>だ。</p>

<pre><code class="diff">$ git diff rango/views.py
diff --git a/rango/views.py b/rango/views.py
index 117afb3..6aeae71 100644
--- a/rango/views.py
+++ b/rango/views.py
@@ -1,5 +1,21 @@
 from django.http import HttpResponse
+from django.shortcuts import render


 def index(request):
-    return HttpResponse("Rango says hey there partner!")
+    """
+    Construct a dicitionary to pass to the template engine as its context.
+    Note the key boldmessage is the same as  in the template!
+    """
+    context_dict = {'boldmessage': 'Crunchy, creamy, cookie, candy, cupcake!'}
+
+    """
+    Return a rendered response to send to the client.
+    We make use of the shortcut function to make our lives easier.
+    Note that the first parameter is the template we wish to use.
+    """
+    return render(request, 'rango/index.html', context=context_dict)
</code></pre>

<p>これも見れば大体わかるだろう。<code>render(request, 'index.html', context=context_dict)</code>だけに注目すれば良い。<code>render</code>の引数の１つ目はリクエストオブジェクトだ。これはお作法として「１つめはリクエストオブジェクト」とおぼえておけば良い。２つ目の引数は、このレンダリング処理が利用するテンプレートの位置を教えている。ディレクトリの位置は先ほど<code>'DIRS': [TEMPLATE_DIR, ]</code>と設定しているので、ここでは<code>TEMPLATE_DIR</code>以降の相対パスを記述すれば良い、ということになる。では３つ目は？これはcontextを渡している。一口にcontextといっても意味するところはまさにcontextに依存するわけだが、ここでは「テンプレートファイルに渡す情報」と理解しておけば良い。よって<code>context=context_dict</code>は<code>{'boldmessage': 'Crunchy, creamy, cookie, candy, cupcake!'}</code>という辞書変数をテンプレートファイルに渡していることを意味する。</p>

<p>さて、コードの順序とは逆だが、ここでテンプレートファイルに渡しているコンテキスト情報を見てみる。キーが<code>boldmessage</code>で値が<code>Crunchy, creamy, cookie, candy, cupcake!</code>だ。今回の処理では、「テンプレートファイルの中にある<code>boldmessage</code>というプレースホルダーに<code>Crunchy, creamy, cookie, candy, cupcake!</code>という値を渡す」ということになる。実際に<code>python runserver</code>を実行して <a href="http://127.0.0.1:8000/rango/">http://127.0.0.1:8000/rango/</a> にアクセスすると太字になった<strong>Crunchy, creamy, cookie, candy, cupcake!</strong>がブラウザに表示されるはずだ。</p>

<p>HTMLが配信されるようになった。とくれば次はCSSやJavascriptなどを使いたくなる。このような静的なファイルは本来はDjangoの守備範囲ではない。なぜならば、これは「静的」であり、サーバーサイドで生成するようなものではないからだ。とはいえ、Djangoアプリケーションで静的ファイルを配信することはもちろん可能である。</p>

<p>まず静的ファイルを配置するディレクトリを設定する。今回はtemplateディレクトリと同様にプロジェクトのルートに<code>static</code>ディレクトリを配置する。</p>

<pre><code class="console">$ ls -l
total 20
drwxr-xr-x 11 sgyk   374  9  6 23:16 ./
drwxr-xr-x  9 sgyk   306  9  4 22:40 ../
drwxr-xr-x 12 sgyk   408  9  6 22:55 .git/
-rw-r--r--  1 sgyk  3329  9  4 23:09 .gitignore
drwxr-xr-x 12 sgyk   408  9  6 23:01 .idea/
-rw-r--r--  1 sgyk 12288  9  4 22:52 db.sqlite3
-rwxr-xr-x  1 sgyk   823  9  4 22:40 manage.py*
drwxr-xr-x 11 sgyk   374  9  6 22:48 rango/
drwxr-xr-x  2 sgyk    68  9  6 23:16 static/    # &lt;- コレ
drwxr-xr-x  7 sgyk   238  9  6 22:48 tango_with_django_project/
drwxr-xr-x  3 sgyk   102  9  6 22:47 templates/
</code></pre>

<p>次にtemplatesディレクトリのときと同様にDjangoにstaticディレクトリの位置を教えてあげれば良い。ここでも絶対パスとして定義するようにすること。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 634f1b7..cc817d7 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -121,3 +121,5 @@ USE_TZ = True
 # https://docs.djangoproject.com/en/1.11/howto/static-files/

 STATIC_URL = '/static/'
+
+STATIC_DIR = os.path.join(BASE_DIR, 'static')
</code></pre>

<p>次に<code>STATICFILES_DIRS</code>を定義する。以下のようにすれば良い。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 634f1b7..2cec3bc 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -121,3 +121,7 @@ USE_TZ = True
 # https://docs.djangoproject.com/en/1.11/howto/static-files/

 STATIC_URL = '/static/'

STATIC_DIR = os.path.join(BASE_DIR, 'static')
+
+STATICFILES_DIRS = [STATIC_DIR, ]
</code></pre>

<p><code>STATICFILES_DIRS</code>については「そういうもの」とおぼえておけばよい。要はお作法なのだ。詳細を知りたいなら <a href="https://docs.djangoproject.com/en/1.11/howto/static-files/">https://docs.djangoproject.com/en/1.11/howto/static-files/</a> を参照すること。また、<code>STATIC_URL = '/static/'</code>もちゃんと定義されていることを確認すること。これはDjangoプロジェクトを始める時点で生成されるファイルに予め記述されているはずだが、なければ上記のように定義しておく。<code>STATIC_URL</code>は定義されている値から想像できるように、静的ファイルを配信するときのURLだ。例えば、画像を/static/rango.jpgとして配置すると、ブラウザ上では <a href="http://127.0.0.1:8000/static/rango.jpg">http://127.0.0.1:8000/static/rango.jpg</a> としてアクセスできるようになる。また、<code>STATIC_URL</code>に定義する値はスラッシュを前後につけること。<code>STATIC_URL  = 'static/'</code>や<code>STATIC_URL  = '/static'</code>ではエラーになる。</p>

<p>では静的ファイルをどのようにテンプレートに組み込むか。これは簡単だ。まずは変更後のテンプレートファイルを見て欲しい。
<code>diff 
$ git diff templates/rango/index.html
diff --git a/templates/rango/index.html b/templates/rango/index.html
index 8d06f2d..6895561 100644
--- a/templates/rango/index.html
+++ b/templates/rango/index.html
@@ -1,4 +1,7 @@
 &lt;!DOCTYPE html&gt;
+
+{% load staticfiles %}
+
 &lt;html lang="en"&gt;
 &lt;head&gt;
   &lt;meta charset="UTF-8"&gt;
@@ -13,5 +16,9 @@
 &lt;div&gt;
   &lt;a href="http://sgykfjsm.github.io/rango/about/"&gt;About&lt;/a&gt;
 &lt;/div&gt;
+&lt;div&gt;
+  &lt;img src="{% static "rango.jpg" %}" alt="Picture of Rango" /&gt;
+&lt;/div&gt;
+
 &lt;/body&gt;
 &lt;/html&gt;
</code></p>

<p>テンプレートファイルの上部で<code>{% load staticfiles %}</code>と書いてDjangoに対して静的ファイルを使うことを宣言する。次に通常のHTMLタグを記述して参照したい静的ファイルを<code>{% static "rango.jpg" %}</code>と書く。これについて説明する。<code>{{ foo }}</code>をプレースホルダーと呼んでいたのに対して、<code>{% ... %}</code>は<strong>テンプレートタグ</strong>と呼ぶ。詳細な説明は一旦スキップして、ここでは<code>{% static %}</code>として先ほど設定した<code>STATIC_URL</code>と結びついて参照先URLを生成する。つまり、コードで表現すると<code>{% static "rango.jpg" %}</code>は<code>STATIC_URL + "rango.jpg"</code>となり<code>/static/smile.jpg</code>という文字列を生成する。</p>

<p>先述した静的ファイルの配信はあくまでサイトないしはWebアプリケーションのアセットを前提としたものだった。しかし、例えばユーザーやサイト管理者が任意に画像をアップロードし、それをコンテンツとして配信しないといけない場合はどうだろうか。こういったファイルは更新または削除されうるため、「静的」なコンテンツとは言えない。しかし、サーバーサイドのアプリケーションが生成するとも言えない。こういった場合、やはりDjangoに「このファイルは外部ユーザーが管理しているファイルですよ」と教えてあげる設定をしてあげれば良い。</p>

<p>まずは以下の様に外部からアップロードされるファイルを保存する場所を設定する。</p>

<pre><code class="diff">$ git diff tango_with_django_project/settings.py
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 2cec3bc..7e8a909 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -125,3 +125,9 @@ STATIC_URL = '/static/'
 STATIC_DIR = os.path.join(BASE_DIR, 'static')

 STATICFILES_DIRS = [STATIC_DIR, ]
+
+MEDIA_DIR = os.path.join(BASE_DIR, 'media')
+
+MEDIA_ROOT = MEDIA_DIR
+
+MEDIA_URL = '/media/'
</code></pre>

<p>次に、この<code>MEDIA_URL</code>をアプリケーションのURLとして登録してあげる。</p>

<pre><code class="diff">$ git diff tango_with_django_project/urls.py
diff --git a/tango_with_django_project/urls.py b/tango_with_django_project/urls.py
index 85abbc4..7050919 100644
--- a/tango_with_django_project/urls.py
+++ b/tango_with_django_project/urls.py
@@ -13,13 +13,15 @@ Including another URLconf
     1. Import the include() function: from django.conf.urls import url, include
     2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
 """
+from django.conf import settings
 from django.conf.urls import url
 from django.contrib import admin
 from django.conf.urls import include
+from django.conf.urls.static import static
 from rango import views

 urlpatterns = [
     url(r'^$', views.index, name='index'),
     url(r'^rango/', include('rango.urls')),
     url(r'^admin/', admin.site.urls),
-]
+] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
</code></pre>

<p>これにより、<a href="http://127.0.0.1:8000/media/user.jpg">http://127.0.0.1:8000/media/user.jpg</a> などのようにアクセスできるようになる。</p>

<p>なお、<code>django.conf.urls.static.static</code>を見ればわかるが、このURLでアクセスできるのはsettings.pyの中で<code>DEBUG = True</code>となっているときだけである。詳細は <a href="https://docs.djangoproject.com/en/1.11/howto/static-files/#serving-files-uploaded-by-a-user-during-development">https://docs.djangoproject.com/en/1.11/howto/static-files/#serving-files-uploaded-by-a-user-during-development</a> を参照すること。</p>

<p>次に、テンプレートで使用する場合はリクエストオブジェクトに<code>MEDIA_URL</code>の情報を与えるために<code>django.template.context_processors.media</code>を与える。このcontext_processorsについては <a href="https://docs.djangoproject.com/en/1.11/ref/templates/api/#django-template-context-processors-media">https://docs.djangoproject.com/en/1.11/ref/templates/api/#django-template-context-processors-media</a> を参照すること。</p>

<pre><code class="diff">$ git diff tango_with_django_project/settings.py
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 7e8a909..68b8335 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -65,6 +65,7 @@ TEMPLATES = [
                 'django.template.context_processors.request',
                 'django.contrib.auth.context_processors.auth',
                 'django.contrib.messages.context_processors.messages',
+                'django.template.context_processors.media',
             ],
         },
     },
</code></pre>

<p>テンプレートへの実際の埋め込みは以下の通り。上の設定でリクエストオブジェクトは<code>MEDIA_URL</code>が使えるようになっているので、素直にそのまま設定すれば良い。</p>

<pre><code class="diff ">/tango_with_django_project (git)-[master][!][*]
$ git diff templates/rango/
diff --git a/templates/rango/index.html b/templates/rango/index.html
index 6895561..08398ef 100644
--- a/templates/rango/index.html
+++ b/templates/rango/index.html
@@ -19,6 +19,8 @@
 &lt;div&gt;
   &lt;img src="{% static "smile.jpg" %}" alt="Picture of Rango" /&gt;
 &lt;/div&gt;
-
+&lt;div&gt;
+  &lt;img src="{{ MEDIA_URL }}user.jpg" %}" alt="Picture of User" /&gt;
+&lt;/div&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</code></pre>

<p>テンプレートの話はとりあえずここまで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DjangoをTango with Djangoで学ぶ - 1 -]]></title>
    <link href="http://sgykfjsm.github.io/blog/2017/09/07/djangowotango-with-djangodexue-bu-1/"/>
    <updated>2017-09-07T00:12:56+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2017/09/07/djangowotango-with-djangodexue-bu-1</id>
    <content type="html"><![CDATA[<p>仕事でDjangoアプリケーションを扱うことになったのでDjangoについて勉強を始めた。参考書として<a href="http://www.tangowithdjango.com/">Tango With Django</a>を購入した。古いバージョンなら無料で入手できるっぽいけど大して高価な本というわけでもないし購入したほうが良いかなと思って買った。</p>

<p>さて、最初は環境の準備を行い、それからViewの基本とURLマッピングについての学習だ。</p>

<!-- more -->


<a name="L......"></a>
<h1>準備</h1>

<p>これはTango With Djangoに書いてあるやり方ではなくて、いつも自分がPython環境を構築するときのやり方だ。要はDjangoを指定のPythonバージョンで動かせばよいわけだから、いつものやり方で良い。</p>

<a name="L..............."></a>
<h2>必要なもの</h2>

<p><a href="https://github.com/pyenv/pyenv">pyenv</a>と<a href="https://github.com/pyenv/pyenv-virtualenv">pyenv-virtualenv</a>がinstallされていること。</p>

<a name="L......"></a>
<h2>手順</h2>

<p>pyenvにバージョン3.5.3をインストールする。</p>

<pre><code>$ pyenv install 3.5.3
Downloading Python-3.5.3.tar.xz...
-&gt; https://www.python.org/ftp/python/3.5.3/Python-3.5.3.tar.xz
Installing Python-3.5.3...
Installed Python-3.5.3 to /Users/sgyk/.pyenv/versions/3.5.3
</code></pre>

<p>作業用Pythonの設定をする。</p>

<pre><code>$ eval "$(pyenv init -)"
$ eval "$(pyenv virtualenv-init -)"
$ pyenv virtualenv 3.5.3 tango-with-django-env
$ pyenv activate tango-with-django-env
$ python --version
Python 3.5.3
</code></pre>

<a name="Django...install................................."></a>
<h2>Djangoをinstallしてプロジェクトを作る</h2>

<pre><code>$ pip install django
# Confirm django is installed as expected
$ python
Python 3.5.3 (default, Sep  4 2017, 22:33:15)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import django
&gt;&gt;&gt; django.get_version()
'1.11.4'
&gt;&gt;&gt; exit()
# $ cd ${YOUR_WORKSPACE}
$ cd tango_with_django_project
$ django-admin.py startproject tango_with_django_project
$ cd tango_with_django_project/
$ ls -l
total 4
drwxr-xr-x 4 sgyk 136  9  4 22:40 ./
drwxr-xr-x 9 sgyk 306  9  4 22:40 ../
-rwxr-xr-x 1 sgyk 823  9  4 22:40 manage.py*
drwxr-xr-x 6 sgyk 204  9  4 22:40 tango_with_django_project/   # &lt;- project configuration directrory
</code></pre>

<p>ここまでで準備は完了。とりあえず起動してみる</p>

<pre><code>$ python manage.py runserver
Performing system checks...

System check identified no issues (0 silenced).

You have 13 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.

....
</code></pre>

<p>warningが出ているが、これはDBを使うようになるまで放置で良い。<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> にアクセスして&#8221;It worked!&ldquo;が表示されることを確認すること。</p>

<a name="L................................."></a>
<h2>アプリケーションの準備</h2>

<p>ここまではプロジェクトの準備。ここからはアプリケーションの準備を始める。今回はテキストに則ってrangoというアプリケーションを作成する。アプリケーションの準備は以下の通りにコマンドを叩けば良い。</p>

<pre><code>$ python manage.py startapp rango
</code></pre>

<p><code>startapp</code>コマンドはプロジェクトディレクトリのルートに新しいディレクトリを作成する。</p>

<pre><code>$ ls -l
total 16
drwxr-xr-x 6 sgyk   204  9  4 22:58 ./
drwxr-xr-x 9 sgyk   306  9  4 22:40 ../
-rw-r--r-- 1 sgyk 12288  9  4 22:52 db.sqlite3
-rwxr-xr-x 1 sgyk   823  9  4 22:40 manage.py*
drwxr-xr-x 9 sgyk   306  9  4 22:58 rango/
drwxr-xr-x 7 sgyk   238  9  4 22:52 tango_with_django_project/
</code></pre>

<p><code>db.sqlite3</code>と<code>rango</code>ディレクトリが作成されたことが確認できる。<code>rango</code>ディレクトリの中身は以下の通り。</p>

<pre><code>$ ls -l ./rango/
total 20
drwxr-xr-x 9 sgyk 306  9  4 22:58 ./
drwxr-xr-x 6 sgyk 204  9  4 22:58 ../
-rw-r--r-- 1 sgyk   0  9  4 22:58 __init__.py
-rw-r--r-- 1 sgyk  63  9  4 22:58 admin.py
-rw-r--r-- 1 sgyk  85  9  4 22:58 apps.py
drwxr-xr-x 3 sgyk 102  9  4 22:58 migrations/
-rw-r--r-- 1 sgyk  57  9  4 22:58 models.py
-rw-r--r-- 1 sgyk  60  9  4 22:58 tests.py
-rw-r--r-- 1 sgyk  63  9  4 22:58 views.py
</code></pre>

<p>Djangoの開発では主に<code>views.py</code>と<code>models.py</code>を扱う。Djangoのmodel, viewsそしてtemplatesがどのように関連しているかは <a href="https://docs.djangoproject.com/en/1.11/intro/overview/">https://docs.djangoproject.com/en/1.11/intro/overview/</a> を参照すると良い。</p>

<p>なお、このあたりで<code>git init</code>しておくと良い。</p>

<a name="L..............."></a>
<h2>最後の準備</h2>

<p>これでアプリケーションの準備ができたので開発を始めることができると思いきや、まだしなければならないことがある。それは、Djangoにこれから開発するアプリケーションについて教えてあげないといけない。具体的には<code>tango_with_django_project/settings.py</code>にこれから追加するアプリケーションの情報を追加しなければならない。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 63c1c9a..8d38aa9 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -37,6 +37,7 @@ INSTALLED_APPS = [
     'django.contrib.sessions',
     'django.contrib.messages',
     'django.contrib.staticfiles',
+    'rango',
 ]

 MIDDLEWARE = [
</code></pre>

<p>上記を追加したら<code>python manage.py runserver</code>を実行し、先ほどと同じようにサーバーが起動することを確認する。</p>

<a name="View....................."></a>
<h1>Viewの開発の１歩目</h1>

<p>Viewの開発を始める。まずは既存のviews.pyを以下の様に書き換えてみる。</p>

<pre><code class="diff">$ git diff
diff --git a/rango/views.py b/rango/views.py
index 91ea44a..117afb3 100644
--- a/rango/views.py
+++ b/rango/views.py
@@ -1,3 +1,5 @@
-from django.shortcuts import render
+from django.http import HttpResponse

-# Create your views here.
+
+def index(request):
+    return HttpResponse("Rango says hey there partner!")
</code></pre>

<p>ここからわかることは、Viewの仕事は基本的に<code>HttpResponse</code>を返すことだ。</p>

<p><code>index</code>が受け取っている<code>request</code>とは簡単に言うとRequestオブジェクトである。この中に様々なリクエスト情報が含まれているが、ここでは使っていない。そのため、引数<code>request</code>を削除しても良いかと思うかもしれないが、これは残しておかないと次に設定するURLのマッピング処理に失敗するので、残しておくこと。</p>

<p>すでに触れたが、上記のviews.pyの修正だけでは、<code>index</code>の処理にアクセスすることはできない。なぜならば、Djangoに<code>index</code>へのアクセスするルートを教えていないからだ。このURLマッピング処理は以下の通りに行えば良い。</p>

<pre><code class="diff">$ git diff tango_with_django_project/urls.py
diff --git a/tango_with_django_project/urls.py b/tango_with_django_project/urls.py
index af5caa3..c385489 100644
--- a/tango_with_django_project/urls.py
+++ b/tango_with_django_project/urls.py
@@ -15,7 +15,9 @@ Including another URLconf
 """
 from django.conf.urls import url
 from django.contrib import admin
+from rango import views

 urlpatterns = [
+    url(r'^$', views.index, name='index'),
     url(r'^admin/', admin.site.urls),
 ]
</code></pre>

<p><code>url(r'^$', views.index, name='index')</code>が意味するのは、URLのルートにアクセスしたら(<code>r'^$'</code>), <code>views.index</code>にリクエスト情報を渡して処理をさせる、この処理の名前を<code>index</code>とする(<code>name='index'</code>)、ということだ。<code>name='index'</code>は一見すると無意味な設定に見えるかもしれないが、DjangoのWarningに使われたりするので、いざという時に重要な情報となる。また、Djangoの<a href="https://docs.djangoproject.com/en/1.11/topics/http/urls/#reverse-resolution-of-urls">Reverse URL Matching</a>にも利用される。よって、設定しておくのが良い。</p>

<a name="URL............................................."></a>
<h2>URLのマッピングに関するテクニック</h2>

<p>上述したようにURLを一つずつ設定していくことによって、URLとViewを対応付けることができる。しかし、設定したファイルは<code>tango_with_django_project</code>というプロジェクトの全体設定ファイルである。今は良いが、今後開発が進んでチームで開発するようになることを考えると、いつまでも全体設定ファイルを扱うことはあまり好ましくない。なぜならば、変更の衝突などが発生しうるからだ。これを避けるためには、以下の様にアプローチすれば良い。</p>

<ol>
<li>全体設定ファイルにはアプリケーションのURLのプレフィックスを設定する。</li>
<li>設定したプレフィックスに該当するURLが参照するURLマッピング設定ファイルをアプリケーションのディレクトリ以下に配置する。</li>
</ol>


<p>これにより、アプリケーションとURLマッピング設定ファイルを１：１対応させることができ、アプリケーション開発者は他のアプリケーション設定に関して気にしなくて良くなる。具体的には以下の様に設定すれば良い。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/urls.py b/tango_with_django_project/urls.py
index c385489..85abbc4 100644
--- a/tango_with_django_project/urls.py
+++ b/tango_with_django_project/urls.py
@@ -15,9 +15,11 @@ Including another URLconf
 """
 from django.conf.urls import url
 from django.contrib import admin
+from django.conf.urls import include
 from rango import views

 urlpatterns = [
     url(r'^$', views.index, name='index'),
+    url(r'^rango/', include('rango.urls')),
     url(r'^admin/', admin.site.urls),
 ]
</code></pre>

<p><code>url(r'^rango/', include('rango.urls'))</code>の重要な部分は<code>include('rango.urls')</code>だ。これは<code>rango/</code>から始まるURLのマッピング処理を<code>rango.urls</code>に任せる、という意味になる。<code>rango.urls</code>とは言うまでもなく、rangoアプリケーションの下にある<code>urls</code>というモジュール（あるいは<code>rango/urls.py</code>と言い換えることもできる）のことだ。この設定に従い、rangoディレクトリに<code>urls.py</code>というファイルを作成する。<code>tango_with_django_project/urls.py</code>をコピペして作ればよい。具体的には以下のようになる。</p>

<pre><code class="python">$ cat rango/urls.py
from django.conf.urls import url

from rango import views

urlpatterns = [
    url(r'^$', views.index, name='rango_index'),
]
</code></pre>

<p>記述内容は先述したとおりなので、ここでは割愛する。重要なのは<code>r'^$'</code>だ。<code>include('rango.urls')</code>によってリクエスト情報が渡されるわけだが、<strong>マッチングするURLから<code>rango/</code>が削除される</strong>。例えば、<code>rango/my-page</code>というURLがリクエストされたとすると、<code>rango.urls</code>が処理するURLは<code>my-page/</code>となる。この点に注意すること。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonでコーディングするときの小ネタ]]></title>
    <link href="http://sgykfjsm.github.io/blog/2015/04/21/coding-by-python-with-little-tips/"/>
    <updated>2015-04-21T22:49:59+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2015/04/21/coding-by-python-with-little-tips</id>
    <content type="html"><![CDATA[<p><a href="https://julien.danjou.info/books/the-hacker-guide-to-python">The Hacker&rsquo;s Guide to Python</a>という本を読んでいるんだけれども、その中でちょっと感動したテクニックをメモしておく。</p>

<!-- more -->


<p>まずはコレ。</p>

<pre><code class="python">def get_fruits(basket, fruit):
    """A variation is to use 'if fruit in basket:'"""
    try:
        return basket[fruit]
    except KeyError:
        return set()
</code></pre>

<p>dictの中から指定した要素の値を取得する。ただし、指定した要素が無ければ空のsetオブジェクトを返す。っていう、よくあるパターン。これは以下の様に書き換えることができる。</p>

<pre><code class="python">def get_fruits(basket, fruit):
    # dict.get(key[, default])はkeyが辞書にあればkeyに対する値を返し、
    # そうでなければdefaultを返す。
    return basket.get(fruit, set())
</code></pre>

<p>(コメントを除けば)たった1行になった。しかもこれは<a href="http://docs.python.jp/2/library/stdtypes.html#dict.get">dictの組み込み関数</a>なので、ごく自然に使うことができる。</p>

<p>次の例も意外とありがちだと思う。不正な値が検査対象のオブジェクトに含まれていないかを検める例。</p>

<pre><code class="python">def has_invalid_fields(fields):
    for field in fields:
        if field in ['foo', 'bar']:
            return False
    return True
</code></pre>

<p>これは以下の様に書き換えることができる。</p>

<pre><code class="python">def has_invalid_fields(fields):
    return bool(set(fields) - set(['foo', 'bar']))
</code></pre>

<p>単純にそれぞれの集合の差で判定しているだけ。極めて自然だし、わかりやすい。なんでこうゆう簡潔なコードを思いつけないんだ、おれは…。先ほどの例もそうだけど、データ構造の特性やデータ構造に組み込まれた関数をうまく使うことでコードをより自然に、かつ簡潔にすることができる。</p>

<p>次の例はデータ特性を活かして、パフォーマンスを改善させる例。まずは改善前のコード。</p>

<pre><code class="python">def add_animal_in_family(species, animal, family):
    if family not in species:
        species[family] = set()
    species[family].add(animal)

species = {}
add_animal_in_family(species, 'cat', 'felidea')
</code></pre>

<p>speciesという辞書に新たな要素を追加する場合に、追加する種別(ここでは<code>add_animal_in_family</code>の3つ目の引数)がキーにあるかどうかを確認して、なければ空の集合を入れておく。そののちに指定された値を辞書に追加している。コレ自体は極めて真っ当なコードなんだけど、もし、この<code>add_animal_in_family</code>が100回、1000回と実行されるとしたらどうだろうか？おそらく実行回数が増えるにつれて、if文の条件判定が無駄になることが多くなってくるはずだ。</p>

<p>この問題を改善するのが<code>collections.defalutdict</code>というデータ構造。こいつをうまいこと使ってあげると、エレガントに対応できる。</p>

<pre><code class="python">import collections

def add_animal_in_family(species, animal, family):
    species[family].add(animal)

species = collections.defalutdict(set)
add_animal_in_family(species, 'cat', 'felidea')
</code></pre>

<p>見ての通り、<code>collections</code>パッケージをimportして、データの初期化に<code>collections.defaultdict</code>を使うだけで、<code>add_animal_in_family</code>のif文が不要になってしまった。詳しくは<a href="http://docs.python.jp/2/library/collections.html#collections.defaultdict">ドキュメント</a>を参照するのが一番確実なんだけど、簡単に説明すると、<code>collections.defalutdict</code>に対して存在しない要素へアクセスをしようとすると、<code>defaultdict</code>はKeyErrorを送出する代わりに初期化時に渡されたオブジェクトを使って新たな値を構築して自身である辞書に登録して値を返してくれる。ただし、初期化時に渡す値が<code>None</code>の場合はKeyErrorが送出されるので、注意すること。また、<a href="http://docs.python.jp/2/library/collections.html#id2">ドキュメントに記載されている使用例</a>には初期化時に渡すオブジェクトとしてintを指定しているユニークな例があって、有用。</p>

<p>こんな感じでは、pythonではデータの特性をうまく使うことで小賢しいロジックやアルゴリズムの実装を不要にしてくれて、かつパフォーマンス的にも嬉しい実装をすることができる。もちろん、これはpythonに限った話では無いので、どんな言語であっても扱うデータの特性や組み込み関数についてちゃんと把握しておくことは重要っすな。</p>
]]></content>
  </entry>
  
</feed>
