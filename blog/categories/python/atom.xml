<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | sgykfjsm.github.com]]></title>
  <link href="http://sgykfjsm.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://sgykfjsm.github.io/"/>
  <updated>2017-11-19T20:58:46+09:00</updated>
  <id>http://sgykfjsm.github.io/</id>
  <author>
    <name><![CDATA[sgykfjsm]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[models in basic by tango with django]]></title>
    <link href="http://sgykfjsm.github.io/blog/2017/11/19/models-in-basic-by-tango-with-django/"/>
    <updated>2017-11-19T20:15:21+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2017/11/19/models-in-basic-by-tango-with-django</id>
    <content type="html"><![CDATA[<p>Webアプリケーションでデータを保存・参照・更新・削除という、いわゆるCRUD操作を行う場合はデータベースを利用するのが一般的で、特にリレーショナル・データベース（RDB）が利用される。RDBに対する操作はSQLを用いられる。これはまぁ一般常識。フルスタックWebアプリケーションの場合、SQLで操作するデータをModelとして定義し、それをORM(Object Relational Mapper)を使って、Modelとデータ(データベースの中にあるテーブル定義)と対応させる。Djangoでもこういった機能を提供しており、今回はこれを学習する。</p>

<!-- more -->


<p>さて、Tango with Djangoというテキストで開発するアプリケーションはRangoであるが、ここで改めてRangoの要件を簡単に説明とすると、以下の様になる。</p>

<ul>
<li>RangoはWebサイトのURLリンク集である。</li>
<li>WebサイトのURLはCategoryエンティティが持つ分類に関する情報と紐づく</li>
<li>WebサイトのURLで参照されるページの情報（タイトル、URLそして閲覧回数）を持つ。これをPageエンティティと呼ぶ。</li>
<li>PageエンティティはCateforyエンティティを参照する。RDB的に言うと、Categoryエンティティに外部キーを持つ。</li>
<li>CategoryエンティティとPageエンティティはhousesオブジェクトを介して1 to manyの関係を持つ。下図参照。</li>
</ul>


<pre><code>[Category]-|---------&lt;houses&gt;-----|-&lt;[Page]
</code></pre>

<p>さて、早速Modelに関するコーディングを始めていきたいところだが、その前にDjangoアプリケーションにおけるデータベースの設定を確認する。</p>

<p>通常、Djangoアプリケーションをセットアップした時点で以下のような設定が<code>settings.py</code>に含まれているはず。</p>

<p>settings.py</p>

<pre><code class="python"># Database
# https://docs.djangoproject.com/en/1.11/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
</code></pre>

<p>デフォルト設定だとSQlite3を利用することになっているが、もちろんMySQLなど他のデータベースエンジンを利用することができる。その場合の設定の詳細は<a href="https://docs.djangoproject.com/en/1.11/ref/databases/">公式ドキュメントの&#8221;Databases&#8221;</a>を参照すること。</p>

<p>では、これからモデルの定義を行なう。これまでと同様にアプリケーション固有の設定は各アプリケーションディレクトリの下で行う。今回の場合だと<code>rango/model.py</code>が対象だ。</p>

<p>rango/model.py</p>

<pre><code class="python">from django.db import models


class Category(models.Model):
    name = models.CharField(max_length=128, unique=True)

    def __str__(self):
        return self.name


class Page(models.Model):
    category = models.ForeignKey(Category)
    title = models.CharField(max_length=128)
    url = models.URLField()
    views = models.IntegerField(default=0)

    def __str__(self):
        return self.title
</code></pre>

<p>上のコードを見れば何となくそれぞれの意味がわかると思う。<code>class Category</code>はCategoryテーブルを表現している。もう１つの<code>class Page</code>はPageテーブルを表現している。</p>

<p>ここで最も気をつけなければならないことは、各クラスともに<code>models.Model</code>を継承していることだ。これは忘れてはならない。</p>

<p><code>class Category</code>には１つのフィールドが定義されており、それは見ての通りChar型で最大データ長は128バイトでユニーク制約を持つ。これらはメソッド名や引数名を見たら分かると思う。<code>class Page</code>についても同様だ。ここでは利用されていないが、デフォルトを<code>default=</code>で指定することもできるし、カラムがnullableかどうかも指定できる。</p>

<p>テーブル間の関係は<code>one-to-one</code>, <code>one-to-many</code>そして<code>many-to-many</code>の３つに大別できるが、<code>models.ForeignKey</code>によって、<code>one-to-many</code>を表現している。この場合、PageテーブルがCategoryテーブルを参照しているので、PageテーブルがManyで、CategoryテーブルがOneとなる。なお、<code>one-to-one</code>は<code>OneToOneField</code>, <code>many-to-many</code>は<code>ManyToManyField</code>という見たままのネーミングとなっている。</p>

<p>それぞれのクラスには<code>__str__</code>が定義されている。このメソッドは各クラスのオブジェクトを文字列として扱うときに利用されるメソッドだ。これを定義しないと継承元の<code>__str__</code>が呼び出されて、<code>&lt;Category:Category object&gt;</code>というよく分からない文字列が出力されるので、モデルを定義する際には<code>__str__</code>も定義することがベストプラクティスの１つとなる。</p>

<p>最後に注意する点として、各クラスには暗黙的に<code>id</code>カラムが設定され、そのカラムは<code>integer NOT NULL PRIMARY KEY AUTOINCREMENT</code>という設定がされていることだ。</p>

<p>とりあえずはテーブルの定義が完了したので、ここでDjangoのマイグレーションツールを試してみる。</p>

<p>まずはデフォルトで設定されているテーブル類のマイグレーションを行なう。「デフォルトで設定されているテーブル」とは<code>settings.py</code>の中にある<code>INSTALLED_APPS</code>だ。</p>

<p>なお、久しぶりのDjangoコマンドの実行なので、virtualenvのactivateを忘れないようにしよう。</p>

<pre><code class="console">$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying sessions.0001_initial... OK
</code></pre>

<p>これでDjangoにとっての基本的なテーブルが出来た。次にテーブルを操作するためのスーパーユーザー（要はrootユーザーみたいなもの）を用意する。</p>

<pre><code class="console">$ python manage.py createsuperuser
Username (leave blank to use 'you'):
Email address:
Password:
Password (again):
Superuser created successfully.
</code></pre>

<p>つぎに、アプリケーション固有のテーブルのマイグレーション、つまり先ほど定義した<code>rango/models.py</code>を元にマイグレーションを行なう。</p>

<pre><code class="console">$ python manage.py makemigrations rango
Migrations for 'rango':
  rango/migrations/0001_initial.py
    - Create model Category
    - Create model Page
</code></pre>

<p>生成されたファイルの中身を見ても良いが、より確実な確認として、生成したファイルから更に生成されるSQLを確認してみよう</p>

<pre><code>$ python manage.py sqlmigrate rango 0001
BEGIN;
--
-- Create model Category
--
CREATE TABLE "rango_category" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(128) NOT NULL UNIQUE);
--
-- Create model Page
--
CREATE TABLE "rango_page" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(128) NOT NULL, "url" varchar(200) NOT NULL, "views" integer NOT NULL, "category_id" integer NOT NULL REFERENCES "rango_category" ("id"));
CREATE INDEX "rango_page_category_id_0872388a" ON "rango_page" ("category_id");
COMMIT;
</code></pre>

<p>改行されていないので少し見にくいが、期待通りのSQLが生成されていることがわかると思う。</p>

<p><code>makemigrations</code>で生成されたのは<code>migrate</code>で利用されるパーツのようなもの。このパーツをDjangoアプリケーションとして組み込むためにはもう1度<code>migrate</code>を実行すれば良い。</p>

<pre><code>$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, rango, sessions
Running migrations:
  Applying rango.0001_initial... OK
</code></pre>

<p>これでrango固有のテーブルがDjangoアプリケーションに取り込まれた。今回はSQLiteなのでブラウザとして <a href="http://sqlitebrowser.org/">SQLite Database Browser</a> を使うと、取り込まれている様子がわかると思う。</p>

<p>DjangoはShell機能を提供している。といっても実際はただのPythonのREPLではあるけど。起動方法はいつものようにmanage.pyを使う。以下の通り。</p>

<pre><code>$ python manage.py shell
Python 3.5.3 (default, Sep  4 2017, 22:33:15)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
&gt;&gt;&gt;
</code></pre>

<p>この起動によってプロジェクトの諸々の設定も取り込まれる。</p>

<pre><code>$ python manage.py shell
Python 3.5.3 (default, Sep  4 2017, 22:33:15)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
&gt;&gt;&gt; from rango.models import Category
&gt;&gt;&gt; print(Category.objects.all())
&lt;QuerySet []&gt;
&gt;&gt;&gt; c = Category(name="Test")
&gt;&gt;&gt; c.save()
&gt;&gt;&gt; print(Category.objects.all())
&lt;QuerySet [&lt;Category: Test&gt;]&gt;
&gt;&gt;&gt; quit()
</code></pre>

<p>上で紹介したDB Browserを使うと、ちゃんとDBに&#8221;Test&#8221;が保存されていることを確認することができる。</p>

<p>Djangoの目を引く特徴の1つとしてWebの管理画面をデフォルトで提供していることが挙げられる。これを使って、DBの中のデータを見たり編集することができる。ここで改めてプロジェクトディレクトリにある<code>settings.py</code>と<code>urls.py</code>を見ると、以下があることに気づくだろう。</p>

<p>settings.py</p>

<pre><code class="python">...
INSTALLED_APPS = [
    'django.contrib.admin',   # &lt;- これ
...
    'rango',
]
...
</code></pre>

<p>urls.py</p>

<pre><code class="python">...
urlpatterns = [
...
    url(r'^admin/', admin.site.urls),  # &lt;- これ
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
...
</code></pre>

<p>上記2つの設定があることを確認したら<code>python manage.py runserver</code>でアプリケーションを起動してみよう。</p>

<pre><code class="console">$ python manage.py runserver
</code></pre>

<p>早速ブラウザで<a href="http://localhost:8000/admin/">http://localhost:8000/admin/</a> にアクセスするとログイン画面が出てくるので、<code>python manage.py createsuperuser</code>で作成したユーザでログインすれば良い。もしどんなユーザを作成したか忘れてしまったのならば、改めて再作成すれば良い。</p>

<p>ログイン後、表示された画面には<em>AUTHENTICATION AND AUTHORIZATION</em>というタイトルの項目があるが、肝心のrangoアプリケーションのテーブルが存在しないことに気づくだろう。これはDjangoのAdmin機能がrangoアプリケーションのmodelsの存在を知らないからだ。なので、教えてあげる必要がある。<code>rango/admin.py</code>に以下のように編集する。</p>

<p>rango/admin.py</p>

<pre><code class="diff">--- a/rango/admin.py
+++ b/rango/admin.py
@@ -1,3 +1,5 @@
 from django.contrib import admin
+from rango.models import Category, Page

-# Register your models here.
+admin.site.register(Category)
+admin.site.register(Page)
</code></pre>

<p>上記のとおりに編集してWebの画面をリロードすると、<em>RANGO</em>という項目が追加されるはず。&#8221;Categorys&#8221;をクリックすると、先ほどShell機能を使って追加した&#8221;Test&#8221;が存在することがわかる。このような方法でもDBを確認することができるし、おそらくDjangoの開発中はこちらを利用することが多いだろう。</p>

<p>ところで、Webの管理画面では&#8221;Category&#8221;が&#8221;Categorys&#8221;となっていることに気づいただろうか？これは別にDjangoがtypoしているわけではなくて、モデルのメタデータの<code>verbose_name_plural</code>のデフォルト設定によるもの。気になるようであれば、自分で修正することができる。以下の様に。</p>

<p>rango/models.py</p>

<pre><code class="diff">$ git diff | cat -
diff --git a/rango/models.py b/rango/models.py
index c65a919..b9b694d 100644
--- a/rango/models.py
+++ b/rango/models.py
@@ -4,6 +4,9 @@ from django.db import models
 class Category(models.Model):
     name = models.CharField(max_length=128, unique=True)

+    class Meta:
+        verbose_name_plural = 'Categories'
+
     def __str__(self):
         return self.name
</code></pre>

<p>編集後は再度画面をリロードして確認しておくこと。</p>

<p>ここまでの作業でモデルが用意できた。実際の開発では、このモデルにデータを入れて動作確認やテストをしたりするわけだけど、そのためのテストデータを毎回用意するのは正直ダルい。ので、一般的にはpopulation scriptと呼ばれるダミーデータ生成のためのスクリプトを用意する。ダミーデータとは言え、ランダムな文字列を適当に入れても、あまり役に立たない。ここでは、それっぽいデータを用意してDBに格納するスクリプトを書く。<code>populate_rango.py</code>という名前でプロジェクトディレクトリの直下にファイルを用意しよう。こんな感じ。</p>

<p>populate_rango.py</p>

<pre><code class="python">import os
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tango_with_django_project.settings')

import django
django.setup()

from rango.models import Category, Page


def populate():
    python_pages = [
        {"title": "Official Python Tutorial",  "url": "http://docs.python.org/2/tutorial"},
        {"title": "How to Think like a Computer Scientis",  "url": "http://www.greenteapress.com/thinkpython"},
        {"title": "Learn Python in 10 Minutes",  "url": "http://www.korokithakis.net/tutorials/python"},
    ]

    django_pages = [
        {"title": "Official Django Tutorial", "url": "https://docs.djangoproject.com/en/1.9/intro/tutorial01/"},
        {"title": "Django Rocks", "url": "http://djangorocks.com"},
        {"title": "How to Tango with Django", "url": "http://www.tangowithdjango.com/"},
    ]

    other_pages = [
        {"title": "Bottle", "url": "https://bottlepy.org/docs/dev/"},
        {"title": "Flask", "url": "http://flask.pocoo.org/"},
    ]

    cats = {
        "Python": {"pages": python_pages},
        "Django": {"pages": django_pages},
        "Other Frameworks": {"pages": other_pages},
    }

    for cat, cat_data in cats.items():
        c = add_cat(cat)
        for p in cat_data["pages"]:
            add_page(c, p["title"], p["url"])

    for c in Category.objects.all():
        for p in Page.objects.filter(category=c):
            print("- {0} - {1}".format(str(c), str(p)))


def add_page(cat, title, url, views=0):
    p = Page.objects.get_or_create(category=cat, title=title)[0]
    p.url = url
    p.views = views
    p.save()

    return p


def add_cat(name):
    c = Category.objects.get_or_create(name=name)[0]
    c.save()

    return c


if __name__ == '__main__':
    print("Starting Rango population script...")
    populate()
</code></pre>

<p>このスクリプトを簡単に解説する。まず、一番下の<code>if __name__ == '__main__':</code>は「ファイルを直接実行したかどうか」を判定していて、直接実行した場合には<code>"Starting Rango population script..."</code>をターミナルに表示して、<code>populate()</code>という関数を実行する。<code>populate()</code>のほとんどはテストデータの定義だけど、後半の数行は<code>foo</code>ループを実行している。最初のループでは、Categoryテーブルにデータを入れて、それからPageテーブルにデータを追加している。次のループはちゃんとデータが格納されているかどうかを確認するために、テーブルからデータを取り出してターミナルに表示している。それだけ。</p>

<p>実際にpopulate scriptを実行してから<code>python manage.py runserver</code>を実行、ブラウザで<a href="http://127.0.0.1:8000/admin/">http://127.0.0.1:8000/admin/</a> にアクセスして各テーブルのページを開くと、追加したデータを確認できる。</p>

<a name="L..........................."></a>
<h2>ここまでのおさらい</h2>

<p>DjangoにおけるModelsとはデータモデル、より直接的に言うと、データの定義や操作のこととなる。Djangoでは以下のような作業順序で行なうことが一般的だ。</p>

<ol>
<li>自分のDjangoアプリケーションの中に<code>models.py</code>を用意して、その中にテーブル定義をモデルクラスとして記述する。</li>
<li><code>admin.py</code>の中に定義したモデルクラスを登録する。</li>
<li><code>python manage.py makemigrations ${app_name}</code>を実行してマイグレーションの準備を行なう。</li>
<li><code>python manage.py migrate</code>を実行してDBに対するマイグレーションを行なう。</li>
<li>モデルの動作確認やテストのためにpopulation script（ダミーデータの生成スクリプト）を用意する。</li>
</ol>


<p>色々な理由でDBを削除して作り直すことが発生すると思うけど、その場合は<code>python manage.py migrate</code>を実行すればDBが新たに作成される。その際には、ちゃんとマイグレーションのスクリプト（アプリケーションのディレクトリにある<code>migrations</code>ディレクトリの中のスクリプト）がちゃんと存在していることを確認しておくこと。また、管理者用アカウントは<code>`python manage.py createsuperuser</code>を実行して作成する。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DjangoをTango with Djangoで学ぶ - 2 -]]></title>
    <link href="http://sgykfjsm.github.io/blog/2017/09/21/djangowotango-with-djangodexue-bu-2/"/>
    <updated>2017-09-21T00:19:39+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2017/09/21/djangowotango-with-djangodexue-bu-2</id>
    <content type="html"><![CDATA[<p><a href="http://sgykfjsm.github.io/blog/2017/09/07/djangowotango-with-djangodexue-bu-1/">DjangoをTango with Djangoで学ぶ - 1 -</a>の続き</p>

<p>これまでは表示するHTML（ただのテキストだけど）をviews.pyに直接記載していたが、Djangoでも他のWebフレームワークと同様にテンプレートシステムを備えている。</p>

<p>テンプレートシステムとは簡単に言うと、独自のシンタックスとHTMLを混ぜておきて、独自シンタックスの部分をサーバーサイドで指定された文字列などに置き換えたりすることだ。場合によっては多少の制御構文を備えており、ループ文やIF文を提供するテンプレートシステムも多い。</p>

<!-- more -->


<p>Djangoでテンプレートシステムを利用する場合、<code>${workspace}/tango_with_django_project/templates/${application}</code>というフォルダを作ればよい。今回の場合だと以下の様になる。</p>

<pre><code class="console">$ ls -la
total 20
drwxr-xr-x  9 sgyk   306  9  6 09:40 ./
drwxr-xr-x  9 sgyk   306  9  4 22:40 ../
drwxr-xr-x 12 sgyk   408  9  6 09:35 .git/
-rw-r--r--  1 sgyk  3329  9  4 23:09 .gitignore
drwxr-xr-x 12 sgyk   408  9  6 09:35 .idea/
-rw-r--r--  1 sgyk 12288  9  4 22:52 db.sqlite3
-rwxr-xr-x  1 sgyk   823  9  4 22:40 manage.py*
drwxr-xr-x 11 sgyk   374  9  4 23:50 rango/
drwxr-xr-x  8 sgyk   272  9  6 09:40 tango_with_django_project/

$ ls -la tango_with_django_project/
total 12
drwxr-xr-x 8 sgyk  272  9  6 09:40 ./
drwxr-xr-x 9 sgyk  306  9  6 09:40 ../
-rw-r--r-- 1 sgyk    0  9  4 22:40 __init__.py
drwxr-xr-x 6 sgyk  204  9  4 23:39 __pycache__/
-rw-r--r-- 1 sgyk 3166  9  4 23:10 settings.py
drwxr-xr-x 3 sgyk  102  9  6 09:40 templates/
-rw-r--r-- 1 sgyk  930  9  4 23:39 urls.py
-rw-r--r-- 1 sgyk  428  9  4 22:40 wsgi.py

$ ls -la tango_with_django_project/templates/
total 0
drwxr-xr-x 3 sgyk 102  9  6 09:40 ./
drwxr-xr-x 8 sgyk 272  9  6 09:40 ../
drwxr-xr-x 2 sgyk  68  9  6 09:40 rango/
</code></pre>

<p>次にDjangoに<code>tango_with_django_project/templates/rango</code>あるテンプレートを利用するということを教えてあげる必要がある。具体的には<code>tango_with_django_project/settings.py</code>に以下に設定を追加する必要がある。</p>

<pre><code class="python">...
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],  # &lt;-- ここにテンプレートのパスを追加する
        'APP_DIRS': True,
...
</code></pre>

<p>早速追加したいところだけど注意点がある。それは、<code>DIRS</code>に追加するパスは<strong>絶対パス</strong>でなければならないということだ。しかし、通常、開発時のテンプレートのパスとプロダクション環境で動作させるときに配置されるテンプレートのパスは異なるはず。異なる部分はワークスペース部分のパスになる。例えば、開発時は<code>/Users/you/workspace</code>がワークスペースかもしれないが、デプロイ時のパスは<code>/home/production/application</code>となるかもしれない。この違いの吸収するようにしないといけない。</p>

<p>もちろん、各環境ごとのパスを１つずつハードコーディングするのはダメである。一方、<code>tango_with_django_project/settings.py</code>をよく見てみると、次の１文に気づくはずだ。</p>

<pre><code class="python"># Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
</code></pre>

<p><code>BASE_DIR</code>は<code>tango_with_django_project/settings.py</code>の絶対パスを取得して、２つ上のディレクトリパスを取得している。もし<code>/Users/you/workspace/tango_with_django_project/settings.py</code>だとすると、<code>BASE_DIR</code>には<code>/Users/you/workspace</code>が格納される。</p>

<pre><code class="python">$ python
Python 3.5.3 (default, Sep  4 2017, 22:33:15)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.dirname(os.path.dirname("/Users/you/workspace/tango_with_django_project/settings.py"))
'/Users/you/workspace'
</code></pre>

<p>ということで、<code>/Users/you/workspace/tango_with_django_project/templates/rango</code>のようにパスをハードコートするのではなく、<code>BASE_DIR</code>を利用して以下の様に設定すれば良いことになる。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 8d38aa9..3b12343 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -52,10 +52,12 @@ MIDDLEWARE = [

 ROOT_URLCONF = 'tango_with_django_project.urls'

+TEMPLATE_DIR = os.path.join(BASE_DIR, 'templates')
+
 TEMPLATES = [
     {
         'BACKEND': 'django.template.backends.django.DjangoTemplates',
-        'DIRS': [],
+        'DIRS': [TEMPLATE_DIR, ],
         'APP_DIRS': True,
         'OPTIONS': {
             'context_processors': [
</code></pre>

<p>テンプレートの場所の設定が済んだので実際にテンプレートファイルを記述していく。ここでは以下のようなファイルを<code>rango/templates/index.html</code>として用意する。</p>

<p>templates/rango/index.html</p>

<p>&#8220;`html
&lt;!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rango says&hellip;</title>
</head>
<body></p>

<h1>Rango says&#8230;</h1>


<div>
  hey there parther!<br />
  <strong></strong><br />
</div>


<div>
  <a href="http://sgykfjsm.github.io/rango/about/">About</a>
</div>


<p></body>
</html>
&#8220;`</p>

<p>ほとんどはただのHTMLファイルだが、<code></code>をプレースホルダーとして設定している。AnsibleやJinja2などを経験しているならわかるが、このプレースホルダーがサーバーサイドで任意の変数に置き換えられる。</p>

<p>次にレンダリング処理を記述する。記述する箇所はもちろん<code>rango/views.py</code>だ。</p>

<pre><code class="diff">$ git diff rango/views.py
diff --git a/rango/views.py b/rango/views.py
index 117afb3..6aeae71 100644
--- a/rango/views.py
+++ b/rango/views.py
@@ -1,5 +1,21 @@
 from django.http import HttpResponse
+from django.shortcuts import render


 def index(request):
-    return HttpResponse("Rango says hey there partner!")
+    """
+    Construct a dicitionary to pass to the template engine as its context.
+    Note the key boldmessage is the same as  in the template!
+    """
+    context_dict = {'boldmessage': 'Crunchy, creamy, cookie, candy, cupcake!'}
+
+    """
+    Return a rendered response to send to the client.
+    We make use of the shortcut function to make our lives easier.
+    Note that the first parameter is the template we wish to use.
+    """
+    return render(request, 'rango/index.html', context=context_dict)
</code></pre>

<p>これも見れば大体わかるだろう。<code>render(request, 'index.html', context=context_dict)</code>だけに注目すれば良い。<code>render</code>の引数の１つ目はリクエストオブジェクトだ。これはお作法として「１つめはリクエストオブジェクト」とおぼえておけば良い。２つ目の引数は、このレンダリング処理が利用するテンプレートの位置を教えている。ディレクトリの位置は先ほど<code>'DIRS': [TEMPLATE_DIR, ]</code>と設定しているので、ここでは<code>TEMPLATE_DIR</code>以降の相対パスを記述すれば良い、ということになる。では３つ目は？これはcontextを渡している。一口にcontextといっても意味するところはまさにcontextに依存するわけだが、ここでは「テンプレートファイルに渡す情報」と理解しておけば良い。よって<code>context=context_dict</code>は<code>{'boldmessage': 'Crunchy, creamy, cookie, candy, cupcake!'}</code>という辞書変数をテンプレートファイルに渡していることを意味する。</p>

<p>さて、コードの順序とは逆だが、ここでテンプレートファイルに渡しているコンテキスト情報を見てみる。キーが<code>boldmessage</code>で値が<code>Crunchy, creamy, cookie, candy, cupcake!</code>だ。今回の処理では、「テンプレートファイルの中にある<code>boldmessage</code>というプレースホルダーに<code>Crunchy, creamy, cookie, candy, cupcake!</code>という値を渡す」ということになる。実際に<code>python runserver</code>を実行して <a href="http://127.0.0.1:8000/rango/">http://127.0.0.1:8000/rango/</a> にアクセスすると太字になった<strong>Crunchy, creamy, cookie, candy, cupcake!</strong>がブラウザに表示されるはずだ。</p>

<p>HTMLが配信されるようになった。とくれば次はCSSやJavascriptなどを使いたくなる。このような静的なファイルは本来はDjangoの守備範囲ではない。なぜならば、これは「静的」であり、サーバーサイドで生成するようなものではないからだ。とはいえ、Djangoアプリケーションで静的ファイルを配信することはもちろん可能である。</p>

<p>まず静的ファイルを配置するディレクトリを設定する。今回はtemplateディレクトリと同様にプロジェクトのルートに<code>static</code>ディレクトリを配置する。</p>

<pre><code class="console">$ ls -l
total 20
drwxr-xr-x 11 sgyk   374  9  6 23:16 ./
drwxr-xr-x  9 sgyk   306  9  4 22:40 ../
drwxr-xr-x 12 sgyk   408  9  6 22:55 .git/
-rw-r--r--  1 sgyk  3329  9  4 23:09 .gitignore
drwxr-xr-x 12 sgyk   408  9  6 23:01 .idea/
-rw-r--r--  1 sgyk 12288  9  4 22:52 db.sqlite3
-rwxr-xr-x  1 sgyk   823  9  4 22:40 manage.py*
drwxr-xr-x 11 sgyk   374  9  6 22:48 rango/
drwxr-xr-x  2 sgyk    68  9  6 23:16 static/    # &lt;- コレ
drwxr-xr-x  7 sgyk   238  9  6 22:48 tango_with_django_project/
drwxr-xr-x  3 sgyk   102  9  6 22:47 templates/
</code></pre>

<p>次にtemplatesディレクトリのときと同様にDjangoにstaticディレクトリの位置を教えてあげれば良い。ここでも絶対パスとして定義するようにすること。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 634f1b7..cc817d7 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -121,3 +121,5 @@ USE_TZ = True
 # https://docs.djangoproject.com/en/1.11/howto/static-files/

 STATIC_URL = '/static/'
+
+STATIC_DIR = os.path.join(BASE_DIR, 'static')
</code></pre>

<p>次に<code>STATICFILES_DIRS</code>を定義する。以下のようにすれば良い。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 634f1b7..2cec3bc 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -121,3 +121,7 @@ USE_TZ = True
 # https://docs.djangoproject.com/en/1.11/howto/static-files/

 STATIC_URL = '/static/'

STATIC_DIR = os.path.join(BASE_DIR, 'static')
+
+STATICFILES_DIRS = [STATIC_DIR, ]
</code></pre>

<p><code>STATICFILES_DIRS</code>については「そういうもの」とおぼえておけばよい。要はお作法なのだ。詳細を知りたいなら <a href="https://docs.djangoproject.com/en/1.11/howto/static-files/">https://docs.djangoproject.com/en/1.11/howto/static-files/</a> を参照すること。また、<code>STATIC_URL = '/static/'</code>もちゃんと定義されていることを確認すること。これはDjangoプロジェクトを始める時点で生成されるファイルに予め記述されているはずだが、なければ上記のように定義しておく。<code>STATIC_URL</code>は定義されている値から想像できるように、静的ファイルを配信するときのURLだ。例えば、画像を/static/rango.jpgとして配置すると、ブラウザ上では <a href="http://127.0.0.1:8000/static/rango.jpg">http://127.0.0.1:8000/static/rango.jpg</a> としてアクセスできるようになる。また、<code>STATIC_URL</code>に定義する値はスラッシュを前後につけること。<code>STATIC_URL  = 'static/'</code>や<code>STATIC_URL  = '/static'</code>ではエラーになる。</p>

<p>では静的ファイルをどのようにテンプレートに組み込むか。これは簡単だ。まずは変更後のテンプレートファイルを見て欲しい。
<code>diff 
$ git diff templates/rango/index.html
diff --git a/templates/rango/index.html b/templates/rango/index.html
index 8d06f2d..6895561 100644
--- a/templates/rango/index.html
+++ b/templates/rango/index.html
@@ -1,4 +1,7 @@
 &lt;!DOCTYPE html&gt;
+
+{% load staticfiles %}
+
 &lt;html lang="en"&gt;
 &lt;head&gt;
   &lt;meta charset="UTF-8"&gt;
@@ -13,5 +16,9 @@
 &lt;div&gt;
   &lt;a href="http://sgykfjsm.github.io/rango/about/"&gt;About&lt;/a&gt;
 &lt;/div&gt;
+&lt;div&gt;
+  &lt;img src="{% static "rango.jpg" %}" alt="Picture of Rango" /&gt;
+&lt;/div&gt;
+
 &lt;/body&gt;
 &lt;/html&gt;
</code></p>

<p>テンプレートファイルの上部で<code>{% load staticfiles %}</code>と書いてDjangoに対して静的ファイルを使うことを宣言する。次に通常のHTMLタグを記述して参照したい静的ファイルを<code>{% static "rango.jpg" %}</code>と書く。これについて説明する。<code>{{ foo }}</code>をプレースホルダーと呼んでいたのに対して、<code>{% ... %}</code>は<strong>テンプレートタグ</strong>と呼ぶ。詳細な説明は一旦スキップして、ここでは<code>{% static %}</code>として先ほど設定した<code>STATIC_URL</code>と結びついて参照先URLを生成する。つまり、コードで表現すると<code>{% static "rango.jpg" %}</code>は<code>STATIC_URL + "rango.jpg"</code>となり<code>/static/smile.jpg</code>という文字列を生成する。</p>

<p>先述した静的ファイルの配信はあくまでサイトないしはWebアプリケーションのアセットを前提としたものだった。しかし、例えばユーザーやサイト管理者が任意に画像をアップロードし、それをコンテンツとして配信しないといけない場合はどうだろうか。こういったファイルは更新または削除されうるため、「静的」なコンテンツとは言えない。しかし、サーバーサイドのアプリケーションが生成するとも言えない。こういった場合、やはりDjangoに「このファイルは外部ユーザーが管理しているファイルですよ」と教えてあげる設定をしてあげれば良い。</p>

<p>まずは以下の様に外部からアップロードされるファイルを保存する場所を設定する。</p>

<pre><code class="diff">$ git diff tango_with_django_project/settings.py
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 2cec3bc..7e8a909 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -125,3 +125,9 @@ STATIC_URL = '/static/'
 STATIC_DIR = os.path.join(BASE_DIR, 'static')

 STATICFILES_DIRS = [STATIC_DIR, ]
+
+MEDIA_DIR = os.path.join(BASE_DIR, 'media')
+
+MEDIA_ROOT = MEDIA_DIR
+
+MEDIA_URL = '/media/'
</code></pre>

<p>次に、この<code>MEDIA_URL</code>をアプリケーションのURLとして登録してあげる。</p>

<pre><code class="diff">$ git diff tango_with_django_project/urls.py
diff --git a/tango_with_django_project/urls.py b/tango_with_django_project/urls.py
index 85abbc4..7050919 100644
--- a/tango_with_django_project/urls.py
+++ b/tango_with_django_project/urls.py
@@ -13,13 +13,15 @@ Including another URLconf
     1. Import the include() function: from django.conf.urls import url, include
     2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
 """
+from django.conf import settings
 from django.conf.urls import url
 from django.contrib import admin
 from django.conf.urls import include
+from django.conf.urls.static import static
 from rango import views

 urlpatterns = [
     url(r'^$', views.index, name='index'),
     url(r'^rango/', include('rango.urls')),
     url(r'^admin/', admin.site.urls),
-]
+] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
</code></pre>

<p>これにより、<a href="http://127.0.0.1:8000/media/user.jpg">http://127.0.0.1:8000/media/user.jpg</a> などのようにアクセスできるようになる。</p>

<p>なお、<code>django.conf.urls.static.static</code>を見ればわかるが、このURLでアクセスできるのはsettings.pyの中で<code>DEBUG = True</code>となっているときだけである。詳細は <a href="https://docs.djangoproject.com/en/1.11/howto/static-files/#serving-files-uploaded-by-a-user-during-development">https://docs.djangoproject.com/en/1.11/howto/static-files/#serving-files-uploaded-by-a-user-during-development</a> を参照すること。</p>

<p>次に、テンプレートで使用する場合はリクエストオブジェクトに<code>MEDIA_URL</code>の情報を与えるために<code>django.template.context_processors.media</code>を与える。このcontext_processorsについては <a href="https://docs.djangoproject.com/en/1.11/ref/templates/api/#django-template-context-processors-media">https://docs.djangoproject.com/en/1.11/ref/templates/api/#django-template-context-processors-media</a> を参照すること。</p>

<pre><code class="diff">$ git diff tango_with_django_project/settings.py
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 7e8a909..68b8335 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -65,6 +65,7 @@ TEMPLATES = [
                 'django.template.context_processors.request',
                 'django.contrib.auth.context_processors.auth',
                 'django.contrib.messages.context_processors.messages',
+                'django.template.context_processors.media',
             ],
         },
     },
</code></pre>

<p>テンプレートへの実際の埋め込みは以下の通り。上の設定でリクエストオブジェクトは<code>MEDIA_URL</code>が使えるようになっているので、素直にそのまま設定すれば良い。</p>

<pre><code class="diff ">/tango_with_django_project (git)-[master][!][*]
$ git diff templates/rango/
diff --git a/templates/rango/index.html b/templates/rango/index.html
index 6895561..08398ef 100644
--- a/templates/rango/index.html
+++ b/templates/rango/index.html
@@ -19,6 +19,8 @@
 &lt;div&gt;
   &lt;img src="{% static "smile.jpg" %}" alt="Picture of Rango" /&gt;
 &lt;/div&gt;
-
+&lt;div&gt;
+  &lt;img src="{{ MEDIA_URL }}user.jpg" %}" alt="Picture of User" /&gt;
+&lt;/div&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</code></pre>

<p>テンプレートの話はとりあえずここまで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DjangoをTango with Djangoで学ぶ - 1 -]]></title>
    <link href="http://sgykfjsm.github.io/blog/2017/09/07/djangowotango-with-djangodexue-bu-1/"/>
    <updated>2017-09-07T00:12:56+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2017/09/07/djangowotango-with-djangodexue-bu-1</id>
    <content type="html"><![CDATA[<p>仕事でDjangoアプリケーションを扱うことになったのでDjangoについて勉強を始めた。参考書として<a href="http://www.tangowithdjango.com/">Tango With Django</a>を購入した。古いバージョンなら無料で入手できるっぽいけど大して高価な本というわけでもないし購入したほうが良いかなと思って買った。</p>

<p>さて、最初は環境の準備を行い、それからViewの基本とURLマッピングについての学習だ。</p>

<!-- more -->


<a name="L......"></a>
<h1>準備</h1>

<p>これはTango With Djangoに書いてあるやり方ではなくて、いつも自分がPython環境を構築するときのやり方だ。要はDjangoを指定のPythonバージョンで動かせばよいわけだから、いつものやり方で良い。</p>

<a name="L..............."></a>
<h2>必要なもの</h2>

<p><a href="https://github.com/pyenv/pyenv">pyenv</a>と<a href="https://github.com/pyenv/pyenv-virtualenv">pyenv-virtualenv</a>がinstallされていること。</p>

<a name="L......"></a>
<h2>手順</h2>

<p>pyenvにバージョン3.5.3をインストールする。</p>

<pre><code>$ pyenv install 3.5.3
Downloading Python-3.5.3.tar.xz...
-&gt; https://www.python.org/ftp/python/3.5.3/Python-3.5.3.tar.xz
Installing Python-3.5.3...
Installed Python-3.5.3 to /Users/sgyk/.pyenv/versions/3.5.3
</code></pre>

<p>作業用Pythonの設定をする。</p>

<pre><code>$ eval "$(pyenv init -)"
$ eval "$(pyenv virtualenv-init -)"
$ pyenv virtualenv 3.5.3 tango-with-django-env
$ pyenv activate tango-with-django-env
$ python --version
Python 3.5.3
</code></pre>

<a name="Django...install................................."></a>
<h2>Djangoをinstallしてプロジェクトを作る</h2>

<pre><code>$ pip install django
# Confirm django is installed as expected
$ python
Python 3.5.3 (default, Sep  4 2017, 22:33:15)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import django
&gt;&gt;&gt; django.get_version()
'1.11.4'
&gt;&gt;&gt; exit()
# $ cd ${YOUR_WORKSPACE}
$ cd tango_with_django_project
$ django-admin.py startproject tango_with_django_project
$ cd tango_with_django_project/
$ ls -l
total 4
drwxr-xr-x 4 sgyk 136  9  4 22:40 ./
drwxr-xr-x 9 sgyk 306  9  4 22:40 ../
-rwxr-xr-x 1 sgyk 823  9  4 22:40 manage.py*
drwxr-xr-x 6 sgyk 204  9  4 22:40 tango_with_django_project/   # &lt;- project configuration directrory
</code></pre>

<p>ここまでで準備は完了。とりあえず起動してみる</p>

<pre><code>$ python manage.py runserver
Performing system checks...

System check identified no issues (0 silenced).

You have 13 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.

....
</code></pre>

<p>warningが出ているが、これはDBを使うようになるまで放置で良い。<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> にアクセスして&#8221;It worked!&ldquo;が表示されることを確認すること。</p>

<a name="L................................."></a>
<h2>アプリケーションの準備</h2>

<p>ここまではプロジェクトの準備。ここからはアプリケーションの準備を始める。今回はテキストに則ってrangoというアプリケーションを作成する。アプリケーションの準備は以下の通りにコマンドを叩けば良い。</p>

<pre><code>$ python manage.py startapp rango
</code></pre>

<p><code>startapp</code>コマンドはプロジェクトディレクトリのルートに新しいディレクトリを作成する。</p>

<pre><code>$ ls -l
total 16
drwxr-xr-x 6 sgyk   204  9  4 22:58 ./
drwxr-xr-x 9 sgyk   306  9  4 22:40 ../
-rw-r--r-- 1 sgyk 12288  9  4 22:52 db.sqlite3
-rwxr-xr-x 1 sgyk   823  9  4 22:40 manage.py*
drwxr-xr-x 9 sgyk   306  9  4 22:58 rango/
drwxr-xr-x 7 sgyk   238  9  4 22:52 tango_with_django_project/
</code></pre>

<p><code>db.sqlite3</code>と<code>rango</code>ディレクトリが作成されたことが確認できる。<code>rango</code>ディレクトリの中身は以下の通り。</p>

<pre><code>$ ls -l ./rango/
total 20
drwxr-xr-x 9 sgyk 306  9  4 22:58 ./
drwxr-xr-x 6 sgyk 204  9  4 22:58 ../
-rw-r--r-- 1 sgyk   0  9  4 22:58 __init__.py
-rw-r--r-- 1 sgyk  63  9  4 22:58 admin.py
-rw-r--r-- 1 sgyk  85  9  4 22:58 apps.py
drwxr-xr-x 3 sgyk 102  9  4 22:58 migrations/
-rw-r--r-- 1 sgyk  57  9  4 22:58 models.py
-rw-r--r-- 1 sgyk  60  9  4 22:58 tests.py
-rw-r--r-- 1 sgyk  63  9  4 22:58 views.py
</code></pre>

<p>Djangoの開発では主に<code>views.py</code>と<code>models.py</code>を扱う。Djangoのmodel, viewsそしてtemplatesがどのように関連しているかは <a href="https://docs.djangoproject.com/en/1.11/intro/overview/">https://docs.djangoproject.com/en/1.11/intro/overview/</a> を参照すると良い。</p>

<p>なお、このあたりで<code>git init</code>しておくと良い。</p>

<a name="L..............."></a>
<h2>最後の準備</h2>

<p>これでアプリケーションの準備ができたので開発を始めることができると思いきや、まだしなければならないことがある。それは、Djangoにこれから開発するアプリケーションについて教えてあげないといけない。具体的には<code>tango_with_django_project/settings.py</code>にこれから追加するアプリケーションの情報を追加しなければならない。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/settings.py b/tango_with_django_project/settings.py
index 63c1c9a..8d38aa9 100644
--- a/tango_with_django_project/settings.py
+++ b/tango_with_django_project/settings.py
@@ -37,6 +37,7 @@ INSTALLED_APPS = [
     'django.contrib.sessions',
     'django.contrib.messages',
     'django.contrib.staticfiles',
+    'rango',
 ]

 MIDDLEWARE = [
</code></pre>

<p>上記を追加したら<code>python manage.py runserver</code>を実行し、先ほどと同じようにサーバーが起動することを確認する。</p>

<a name="View....................."></a>
<h1>Viewの開発の１歩目</h1>

<p>Viewの開発を始める。まずは既存のviews.pyを以下の様に書き換えてみる。</p>

<pre><code class="diff">$ git diff
diff --git a/rango/views.py b/rango/views.py
index 91ea44a..117afb3 100644
--- a/rango/views.py
+++ b/rango/views.py
@@ -1,3 +1,5 @@
-from django.shortcuts import render
+from django.http import HttpResponse

-# Create your views here.
+
+def index(request):
+    return HttpResponse("Rango says hey there partner!")
</code></pre>

<p>ここからわかることは、Viewの仕事は基本的に<code>HttpResponse</code>を返すことだ。</p>

<p><code>index</code>が受け取っている<code>request</code>とは簡単に言うとRequestオブジェクトである。この中に様々なリクエスト情報が含まれているが、ここでは使っていない。そのため、引数<code>request</code>を削除しても良いかと思うかもしれないが、これは残しておかないと次に設定するURLのマッピング処理に失敗するので、残しておくこと。</p>

<p>すでに触れたが、上記のviews.pyの修正だけでは、<code>index</code>の処理にアクセスすることはできない。なぜならば、Djangoに<code>index</code>へのアクセスするルートを教えていないからだ。このURLマッピング処理は以下の通りに行えば良い。</p>

<pre><code class="diff">$ git diff tango_with_django_project/urls.py
diff --git a/tango_with_django_project/urls.py b/tango_with_django_project/urls.py
index af5caa3..c385489 100644
--- a/tango_with_django_project/urls.py
+++ b/tango_with_django_project/urls.py
@@ -15,7 +15,9 @@ Including another URLconf
 """
 from django.conf.urls import url
 from django.contrib import admin
+from rango import views

 urlpatterns = [
+    url(r'^$', views.index, name='index'),
     url(r'^admin/', admin.site.urls),
 ]
</code></pre>

<p><code>url(r'^$', views.index, name='index')</code>が意味するのは、URLのルートにアクセスしたら(<code>r'^$'</code>), <code>views.index</code>にリクエスト情報を渡して処理をさせる、この処理の名前を<code>index</code>とする(<code>name='index'</code>)、ということだ。<code>name='index'</code>は一見すると無意味な設定に見えるかもしれないが、DjangoのWarningに使われたりするので、いざという時に重要な情報となる。また、Djangoの<a href="https://docs.djangoproject.com/en/1.11/topics/http/urls/#reverse-resolution-of-urls">Reverse URL Matching</a>にも利用される。よって、設定しておくのが良い。</p>

<a name="URL............................................."></a>
<h2>URLのマッピングに関するテクニック</h2>

<p>上述したようにURLを一つずつ設定していくことによって、URLとViewを対応付けることができる。しかし、設定したファイルは<code>tango_with_django_project</code>というプロジェクトの全体設定ファイルである。今は良いが、今後開発が進んでチームで開発するようになることを考えると、いつまでも全体設定ファイルを扱うことはあまり好ましくない。なぜならば、変更の衝突などが発生しうるからだ。これを避けるためには、以下の様にアプローチすれば良い。</p>

<ol>
<li>全体設定ファイルにはアプリケーションのURLのプレフィックスを設定する。</li>
<li>設定したプレフィックスに該当するURLが参照するURLマッピング設定ファイルをアプリケーションのディレクトリ以下に配置する。</li>
</ol>


<p>これにより、アプリケーションとURLマッピング設定ファイルを１：１対応させることができ、アプリケーション開発者は他のアプリケーション設定に関して気にしなくて良くなる。具体的には以下の様に設定すれば良い。</p>

<pre><code class="diff">$ git diff
diff --git a/tango_with_django_project/urls.py b/tango_with_django_project/urls.py
index c385489..85abbc4 100644
--- a/tango_with_django_project/urls.py
+++ b/tango_with_django_project/urls.py
@@ -15,9 +15,11 @@ Including another URLconf
 """
 from django.conf.urls import url
 from django.contrib import admin
+from django.conf.urls import include
 from rango import views

 urlpatterns = [
     url(r'^$', views.index, name='index'),
+    url(r'^rango/', include('rango.urls')),
     url(r'^admin/', admin.site.urls),
 ]
</code></pre>

<p><code>url(r'^rango/', include('rango.urls'))</code>の重要な部分は<code>include('rango.urls')</code>だ。これは<code>rango/</code>から始まるURLのマッピング処理を<code>rango.urls</code>に任せる、という意味になる。<code>rango.urls</code>とは言うまでもなく、rangoアプリケーションの下にある<code>urls</code>というモジュール（あるいは<code>rango/urls.py</code>と言い換えることもできる）のことだ。この設定に従い、rangoディレクトリに<code>urls.py</code>というファイルを作成する。<code>tango_with_django_project/urls.py</code>をコピペして作ればよい。具体的には以下のようになる。</p>

<pre><code class="python">$ cat rango/urls.py
from django.conf.urls import url

from rango import views

urlpatterns = [
    url(r'^$', views.index, name='rango_index'),
]
</code></pre>

<p>記述内容は先述したとおりなので、ここでは割愛する。重要なのは<code>r'^$'</code>だ。<code>include('rango.urls')</code>によってリクエスト情報が渡されるわけだが、<strong>マッチングするURLから<code>rango/</code>が削除される</strong>。例えば、<code>rango/my-page</code>というURLがリクエストされたとすると、<code>rango.urls</code>が処理するURLは<code>my-page/</code>となる。この点に注意すること。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonでコーディングするときの小ネタ]]></title>
    <link href="http://sgykfjsm.github.io/blog/2015/04/21/coding-by-python-with-little-tips/"/>
    <updated>2015-04-21T22:49:59+09:00</updated>
    <id>http://sgykfjsm.github.io/blog/2015/04/21/coding-by-python-with-little-tips</id>
    <content type="html"><![CDATA[<p><a href="https://julien.danjou.info/books/the-hacker-guide-to-python">The Hacker&rsquo;s Guide to Python</a>という本を読んでいるんだけれども、その中でちょっと感動したテクニックをメモしておく。</p>

<!-- more -->


<p>まずはコレ。</p>

<pre><code class="python">def get_fruits(basket, fruit):
    """A variation is to use 'if fruit in basket:'"""
    try:
        return basket[fruit]
    except KeyError:
        return set()
</code></pre>

<p>dictの中から指定した要素の値を取得する。ただし、指定した要素が無ければ空のsetオブジェクトを返す。っていう、よくあるパターン。これは以下の様に書き換えることができる。</p>

<pre><code class="python">def get_fruits(basket, fruit):
    # dict.get(key[, default])はkeyが辞書にあればkeyに対する値を返し、
    # そうでなければdefaultを返す。
    return basket.get(fruit, set())
</code></pre>

<p>(コメントを除けば)たった1行になった。しかもこれは<a href="http://docs.python.jp/2/library/stdtypes.html#dict.get">dictの組み込み関数</a>なので、ごく自然に使うことができる。</p>

<p>次の例も意外とありがちだと思う。不正な値が検査対象のオブジェクトに含まれていないかを検める例。</p>

<pre><code class="python">def has_invalid_fields(fields):
    for field in fields:
        if field in ['foo', 'bar']:
            return False
    return True
</code></pre>

<p>これは以下の様に書き換えることができる。</p>

<pre><code class="python">def has_invalid_fields(fields):
    return bool(set(fields) - set(['foo', 'bar']))
</code></pre>

<p>単純にそれぞれの集合の差で判定しているだけ。極めて自然だし、わかりやすい。なんでこうゆう簡潔なコードを思いつけないんだ、おれは…。先ほどの例もそうだけど、データ構造の特性やデータ構造に組み込まれた関数をうまく使うことでコードをより自然に、かつ簡潔にすることができる。</p>

<p>次の例はデータ特性を活かして、パフォーマンスを改善させる例。まずは改善前のコード。</p>

<pre><code class="python">def add_animal_in_family(species, animal, family):
    if family not in species:
        species[family] = set()
    species[family].add(animal)

species = {}
add_animal_in_family(species, 'cat', 'felidea')
</code></pre>

<p>speciesという辞書に新たな要素を追加する場合に、追加する種別(ここでは<code>add_animal_in_family</code>の3つ目の引数)がキーにあるかどうかを確認して、なければ空の集合を入れておく。そののちに指定された値を辞書に追加している。コレ自体は極めて真っ当なコードなんだけど、もし、この<code>add_animal_in_family</code>が100回、1000回と実行されるとしたらどうだろうか？おそらく実行回数が増えるにつれて、if文の条件判定が無駄になることが多くなってくるはずだ。</p>

<p>この問題を改善するのが<code>collections.defalutdict</code>というデータ構造。こいつをうまいこと使ってあげると、エレガントに対応できる。</p>

<pre><code class="python">import collections

def add_animal_in_family(species, animal, family):
    species[family].add(animal)

species = collections.defalutdict(set)
add_animal_in_family(species, 'cat', 'felidea')
</code></pre>

<p>見ての通り、<code>collections</code>パッケージをimportして、データの初期化に<code>collections.defaultdict</code>を使うだけで、<code>add_animal_in_family</code>のif文が不要になってしまった。詳しくは<a href="http://docs.python.jp/2/library/collections.html#collections.defaultdict">ドキュメント</a>を参照するのが一番確実なんだけど、簡単に説明すると、<code>collections.defalutdict</code>に対して存在しない要素へアクセスをしようとすると、<code>defaultdict</code>はKeyErrorを送出する代わりに初期化時に渡されたオブジェクトを使って新たな値を構築して自身である辞書に登録して値を返してくれる。ただし、初期化時に渡す値が<code>None</code>の場合はKeyErrorが送出されるので、注意すること。また、<a href="http://docs.python.jp/2/library/collections.html#id2">ドキュメントに記載されている使用例</a>には初期化時に渡すオブジェクトとしてintを指定しているユニークな例があって、有用。</p>

<p>こんな感じでは、pythonではデータの特性をうまく使うことで小賢しいロジックやアルゴリズムの実装を不要にしてくれて、かつパフォーマンス的にも嬉しい実装をすることができる。もちろん、これはpythonに限った話では無いので、どんな言語であっても扱うデータの特性や組み込み関数についてちゃんと把握しておくことは重要っすな。</p>
]]></content>
  </entry>
  
</feed>
